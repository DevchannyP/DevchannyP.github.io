---
layout: post
title: "CHAP 11.API 2"
date: 2025-05-17
categories: [backend, language, java]
tags: [backend, language, java]
thumbnail: /assets/img/post-thumbnails/intro10.png
author: Devchanny
---


# ** 📌1. 날짜와 시간을 다루는 이유**

컴퓨터에서 날짜와 시간을 다루는 것은 매우 중요해요. 예를 들어:

✅ 오늘 날짜 출력하기

✅ 생일 계산하기

✅ 예약 시스템에서 날짜 비교하기

Java에서는 여러 방법으로 날짜를 다룰 수 있는데, 오늘은 `Date` 클래스와 `SimpleDateFormat` 클래스를 사용해서 날짜를 출력하는 방법을 배워볼 거예요! 🚀

---

## **2. 날짜 출력하기 (Date 클래스)**

`Date` 클래스는 **현재 날짜와 시간을 가져오는 클래스**예요.

```java
Date now = new Date();
System.out.println(now);
```

🔹 실행 결과 예시

```
Thu Feb 15 12:30:45 KST 2024
```

여기서 각 부분은 다음을 의미해요:

- `Thu` → 요일 (목요일)
- `Feb` → 월 (2월)
- `15` → 일 (15일)
- `12:30:45` → 시:분:초
- `KST` → 대한민국 시간
- `2024` → 연도

---

## **3. 날짜를 원하는 형식으로 출력하기 (SimpleDateFormat)**

기본 출력 방식이 어렵다면, `SimpleDateFormat` 클래스를 이용해 원하는 형태로 바꿀 수 있어요.

```java
SimpleDateFormat sf = new SimpleDateFormat("yyyy년 MM월 dd일 HH시 mm분 ss초 E a");
System.out.println(sf.format(now));
```

🔹 실행 결과

```
2024년 02월 15일 12시 30분 45초 목 오후
```

여기서 형식 기호를 설명해볼게요!

| 기호 | 의미 | 예시 |
| --- | --- | --- |
| yyyy | 연도 | 2024 |
| MM | 월 (2자리) | 02 (2월) |
| dd | 일 (2자리) | 15 |
| HH | 시간 (24시간 형식) | 13 (오후 1시) |
| mm | 분 | 30 |
| ss | 초 | 45 |
| E | 요일 | 목 (Thursday) |
| a | 오전/오후 | 오전 또는 오후 |

이제 원하는 날짜 형식을 자유롭게 만들 수 있어요! 🎉

---

## **4. 문자열을 날짜(Date 객체)로 변환하기**

날짜를 `String`으로 저장해두었다가 다시 날짜 객체로 변환할 수도 있어요!

```java
SimpleDateFormat sf2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String formatDate = "2025-12-25 10:00:00";
Date day = null;

try {
    day = sf2.parse(formatDate);
} catch (ParseException e) {
    e.printStackTrace();
}

System.out.println(day);
```

🔹 실행 결과

```
Thu Dec 25 10:00:00 KST 2025
```

✅ `parse()` 메서드를 사용하면 **문자열을 날짜(Date)로 변환**할 수 있어요.

✅ 만약 잘못된 형식의 날짜를 입력하면 오류가 발생할 수 있기 때문에 `try-catch` 문으로 감싸줍니다.

---

## **5. 날짜 차이 계산하기**

날짜 차이를 계산하려면 `getTime()` 메서드를 활용하면 돼요!

```java
long diffMillis = day.getTime() - now.getTime();
long diffDays = diffMillis / (1000L * 60 * 60 * 24);
System.out.println("날짜 차이(일): " + diffDays);
```

🔹 실행 결과

```
날짜 차이(일): 315
```

✅ `getTime()` 메서드는 **1970년 1월 1일 00:00:00 UTC부터 경과한 밀리초(ms) 값**을 반환해요.

✅ 두 날짜 간의 차이를 계산한 뒤 **밀리초 → 일(day) 단위로 변환**하면 날짜 차이를 구할 수 있어요.

---

## **6. 날짜 더하기 (3일 후의 날짜 구하기)**

날짜를 계산할 때는 `Calendar` 클래스를 쓰는 게 더 편리해요!

```java
Calendar cal = Calendar.getInstance();
cal.setTime(now);
cal.add(Calendar.DATE, 3);
Date newDate = cal.getTime();
System.out.println("3일 후 날짜: " + new SimpleDateFormat("yyyy-MM-dd E요일").format(newDate));
```

🔹 실행 결과

```
3일 후 날짜: 2024-02-18 일요일
```

✅ `Calendar.add(Calendar.DATE, 3)`를 사용하면 **밀리초 계산 없이 간단하게 날짜를 더할 수 있어요!** 🎉

---

## **7. 날짜와 요일 출력하기**

날짜를 출력하면서 요일까지 함께 표시하려면 이렇게 하면 돼요!

```java
System.out.println(new SimpleDateFormat("yyyy-MM-dd E요일").format(day));
```

🔹 실행 결과

```
2025-12-25 목요일
```

✅ `"E요일"`을 사용하면 날짜와 함께 요일도 표시할 수 있어요! 😊

---

## **마무리 정리**

| 기능 | 사용법 |
| --- | --- |
| 현재 날짜 가져오기 | `new Date()` |
| 날짜를 원하는 형식으로 출력 | `SimpleDateFormat` + `format()` |
| 문자열을 날짜로 변환 | `parse()` |
| 날짜 차이 계산 | `getTime()` 활용 |
| 날짜 더하기/빼기 | `Calendar.add()` |
| 날짜 + 요일 출력 | `"E요일"` 포맷 활용 |

## **8. 특정 날짜의 밀리초 값 구하기**

날짜는 내부적으로 **1970년 1월 1일 00:00:00 UTC** 기준으로 **밀리초 단위(long 타입 숫자)**로 저장돼요.

```java
Date now = new Date();
System.out.println("현재 시간의 밀리초 값: " + now.getTime());
System.out.println("현재 시간의 밀리초 값(System.currentTimeMillis()): " + System.currentTimeMillis());
```

🔹 실행 결과 (예시)

```
현재 시간의 밀리초 값: 1709232000000
현재 시간의 밀리초 값(System.currentTimeMillis()): 1709232000000
```

✅ `getTime()`과 `System.currentTimeMillis()`는 같은 값을 반환해요!

✅ `System.currentTimeMillis()`를 사용하면 **현재 시간을 `Date` 객체 없이도 가져올 수 있어요.**

---

## **9. 특정 날짜를 밀리초 값으로 변환하기**

`SimpleDateFormat`을 사용해서 특정 날짜의 밀리초 값을 구할 수도 있어요.

```java
SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd");
String sday = "2025-03-01";
Date day = null;

try {
    day = sf.parse(sday);
} catch (ParseException e) {
    e.printStackTrace();
}

if (day != null) {
    System.out.println(sday + " " + new SimpleDateFormat("E요일").format(day));
    System.out.println("밀리초 값: " + day.getTime());
} else {
    System.out.println("날짜 변환 실패!");
}
```

🔹 실행 결과

```
2025-03-01 토요일
밀리초 값: 1746073200000
```

✅ `"yyyy-MM-dd"` 형식으로 날짜를 `String`에서 `Date` 객체로 변환한 뒤 `getTime()`을 사용하면 밀리초 값을 구할 수 있어요!

---

## **10. 날짜 간격(일 수) 계산하기**

`getTime()`을 사용하면 두 날짜 사이의 차이를 계산할 수 있어요.

```java
SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd");
Date date1 = sf.parse("2024-02-28");
Date date2 = sf.parse("2024-03-10");

long diffMillis = date2.getTime() - date1.getTime();
long diffDays = diffMillis / (1000L * 60 * 60 * 24);

System.out.println("날짜 차이(일): " + diffDays);
```

🔹 실행 결과

```
날짜 차이(일): 11
```

✅ `getTime()`을 사용해서 **두 날짜의 밀리초 차이 → 일(day) 단위로 변환**하면 날짜 간격을 쉽게 구할 수 있어요!

---

## **11. 특정 날짜에서 X일 더하기 (or 빼기)**

날짜를 계산할 때 **밀리초 단위 연산 대신** `Calendar` 클래스를 사용하면 훨씬 편리해요.

```java
Calendar cal = Calendar.getInstance();
cal.setTime(date1);  // 기준 날짜 설정
cal.add(Calendar.DATE, 5); // 5일 추가
System.out.println("5일 후 날짜: " + sf.format(cal.getTime()));

cal.add(Calendar.DATE, -3); // 3일 빼기
System.out.println("3일 전 날짜: " + sf.format(cal.getTime()));
```

🔹 실행 결과

```
5일 후 날짜: 2024-03-04
3일 전 날짜: 2024-03-01
```

✅ `Calendar.add(Calendar.DATE, 값)`을 사용하면 **날짜를 쉽게 더하거나 뺄 수 있어요.**

---

## **12. 날짜 비교하기 (Before, After, Equals)**

`Date` 객체는 비교 연산을 할 수 있어요.

```java
Date date1 = sf.parse("2024-02-28");
Date date2 = sf.parse("2024-03-10");

if (date1.before(date2)) {
    System.out.println("date1은 date2보다 이전 날짜입니다.");
}
if (date2.after(date1)) {
    System.out.println("date2는 date1보다 이후 날짜입니다.");
}
if (date1.equals(date2)) {
    System.out.println("두 날짜는 같습니다.");
}
```

🔹 실행 결과

```
date1은 date2보다 이전 날짜입니다.
date2는 date1보다 이후 날짜입니다.
```

✅ `before()` → 특정 날짜가 다른 날짜보다 이전인지 확인

✅ `after()` → 특정 날짜가 다른 날짜보다 이후인지 확인

✅ `equals()` → 두 날짜가 같은지 확인

---

## **13. 3일 후 날짜 구하기 (밀리초 연산 방식 vs Calendar 방식 비교)**

### **1) 밀리초 연산 방식**

```java
Date now = new Date();
now.setTime(now.getTime() + (1000L * 60 * 60 * 24 * 3));
System.out.println("3일 후 날짜: " + new SimpleDateFormat("yyyy-MM-dd E요일").format(now));
```

✅ 밀리초 단위로 3일을 추가하는 방식

❌ 실수로 잘못된 값을 넣으면 에러가 발생할 수 있음

---

### **2) Calendar 클래스를 활용하는 방식 (더 안전함)**

```java
Calendar cal = Calendar.getInstance();
cal.add(Calendar.DATE, 3);
System.out.println("3일 후 날짜: " + new SimpleDateFormat("yyyy-MM-dd E요일").format(cal.getTime()));
```

✅ `Calendar.add()`를 사용하면 자동으로 날짜 연산을 해주므로 더 안전해요! 🎉

---

## **14. 요일 출력하기**

요일을 출력하려면 `SimpleDateFormat`을 사용하면 돼요.

```java
System.out.println(new SimpleDateFormat("yyyy-MM-dd E요일").format(date1));
```

🔹 실행 결과

```
2024-02-28 수요일
```

✅ `"E요일"`을 사용하면 요일까지 쉽게 출력할 수 있어요!

---

## **15. 정리: 날짜 관련 핵심 기능 요약**

| 기능 | 사용법 |
| --- | --- |
| 현재 날짜 가져오기 | `new Date()` |
| 날짜를 원하는 형식으로 출력 | `SimpleDateFormat` + `format()` |
| 문자열을 날짜로 변환 | `parse()` |
| 날짜 차이 계산 | `getTime()` 활용 |
| 날짜 더하기/빼기 | `Calendar.add(Calendar.DATE, 값)` |
| 특정 날짜의 요일 출력 | `"E요일"` 포맷 활용 |
| 날짜 비교 | `before()`, `after()`, `equals()` |

## **16. 날짜와 시간을 보다 정교하게 다루는 `LocalDateTime` (Java 8 이상)**

`Date`와 `Calendar`는 오래된 클래스라서, Java 8부터는 `java.time` 패키지의 새로운 API가 도입되었어요.

이제는 `LocalDateTime`, `LocalDate`, `LocalTime`을 사용하면 더 직관적이고 편리하게 날짜와 시간을 다룰 수 있어요!

---

### **1) `LocalDateTime`을 사용해 현재 날짜와 시간 가져오기**

```java
import java.time.LocalDateTime;

public class Main {
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        System.out.println("현재 날짜와 시간: " + now);
    }
}
```

🔹 실행 결과

```
현재 날짜와 시간: 2024-02-29T14:30:15.123
```

✅ `LocalDateTime.now()` → 현재 날짜와 시간을 가져옴

✅ `T14:30:15.123` → 시:분:초.밀리초까지 표시됨

---

### **2) 날짜와 시간을 원하는 형식으로 출력 (`DateTimeFormatter`)**

```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Main {
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy년 MM월 dd일 HH시 mm분 ss초");
        String formattedDate = now.format(formatter);

        System.out.println("형식 지정된 날짜와 시간: " + formattedDate);
    }
}
```

🔹 실행 결과

```
형식 지정된 날짜와 시간: 2024년 02월 29일 14시 30분 15초
```

✅ `DateTimeFormatter.ofPattern("yyyy년 MM월 dd일 HH시 mm분 ss초")` → 날짜 형식을 지정

✅ `now.format(formatter)` → 날짜를 원하는 형식으로 변환

---

### **3) `LocalDate`와 `LocalTime`으로 날짜와 시간 분리하기**

```java
import java.time.LocalDate;
import java.time.LocalTime;

public class Main {
    public static void main(String[] args) {
        LocalDate today = LocalDate.now(); // 현재 날짜
        LocalTime now = LocalTime.now();   // 현재 시간

        System.out.println("현재 날짜: " + today);
        System.out.println("현재 시간: " + now);
    }
}
```

🔹 실행 결과

```
현재 날짜: 2024-02-29
현재 시간: 14:30:15.123
```

✅ `LocalDate.now()` → **날짜만 가져옴**

✅ `LocalTime.now()` → **시간만 가져옴**

---

## **17. 날짜 더하기 및 빼기 (`plusDays()`, `minusDays()`)**

```java
import java.time.LocalDate;

public class Main {
    public static void main(String[] args) {
        LocalDate today = LocalDate.now();

        LocalDate nextWeek = today.plusDays(7);
        LocalDate lastWeek = today.minusDays(7);

        System.out.println("오늘 날짜: " + today);
        System.out.println("일주일 후: " + nextWeek);
        System.out.println("일주일 전: " + lastWeek);
    }
}
```

🔹 실행 결과

```
오늘 날짜: 2024-02-29
일주일 후: 2024-03-07
일주일 전: 2024-02-22
```

✅ `plusDays(7)` → **7일을 더함**

✅ `minusDays(7)` → **7일을 뺌**

✅ `plusMonths(1)` / `minusMonths(1)` 도 가능

## **18. 두 날짜 간의 차이 계산 (`ChronoUnit.DAYS.between()`)**

```java
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

public class Main {
    public static void main(String[] args) {
        LocalDate startDate = LocalDate.of(2024, 2, 1);
        LocalDate endDate = LocalDate.of(2024, 2, 29);

        long daysBetween = ChronoUnit.DAYS.between(startDate, endDate);

        System.out.println("두 날짜의 차이(일): " + daysBetween);
    }
}
```

🔹 실행 결과

```
두 날짜의 차이(일): 28
```

✅ `ChronoUnit.DAYS.between(startDate, endDate)` → 날짜 차이를 일 단위로 계산

✅ `ChronoUnit.MONTHS.between(startDate, endDate)` → **개월 단위 계산도 가능**

---

## **19. 특정 날짜의 요일 구하기**

```java
import java.time.LocalDate;
import java.time.DayOfWeek;

public class Main {
    public static void main(String[] args) {
        LocalDate date = LocalDate.of(2024, 3, 1);
        DayOfWeek dayOfWeek = date.getDayOfWeek();

        System.out.println("2024년 3월 1일의 요일: " + dayOfWeek);
    }
}
```

🔹 실행 결과

```
2024년 3월 1일의 요일: FRIDAY
```

✅ `getDayOfWeek()` → 요일을 반환 (`MONDAY`, `TUESDAY`, `WEDNESDAY`, ...)

---

## **20. `LocalDateTime`을 `Date`로 변환하기 (`Date.from()`)**

```java
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;

public class Main {
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        Date date = Date.from(now.atZone(ZoneId.systemDefault()).toInstant());

        System.out.println("LocalDateTime: " + now);
        System.out.println("Date 객체: " + date);
    }
}
```

🔹 실행 결과

```
LocalDateTime: 2024-02-29T14:30:15.123
Date 객체: Thu Feb 29 14:30:15 KST 2024
```

✅ `LocalDateTime`을 `Date`로 변환하려면 `toInstant()`를 사용해야 해요.

---

## **21. `Date`를 `LocalDateTime`으로 변환하기**

```java
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;

public class Main {
    public static void main(String[] args) {
        Date date = new Date();
        LocalDateTime localDateTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();

        System.out.println("Date 객체: " + date);
        System.out.println("LocalDateTime: " + localDateTime);
    }
}
```

🔹 실행 결과

```
Date 객체: Thu Feb 29 14:30:15 KST 2024
LocalDateTime: 2024-02-29T14:30:15.123
```

✅ `toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime()`을 사용해 변환

---

## **22. 요약 정리**

| 기능 | `Date` & `Calendar` 방식 | `LocalDateTime` 방식 (Java 8 이상) |
| --- | --- | --- |
| 현재 날짜/시간 | `new Date()` | `LocalDateTime.now()` |
| 날짜 포맷 변경 | `SimpleDateFormat` | `DateTimeFormatter` |
| 문자열 → 날짜 변환 | `parse()` | `LocalDate.parse()` |
| 날짜 차이 계산 | `getTime()` 활용 | `ChronoUnit.DAYS.between()` |
| 날짜 더하기/빼기 | `Calendar.add()` | `plusDays()`, `minusDays()` |

### 

---

# **23. 정규 표현식(Regex)란?**

정규 표현식(Regex, Regular Expression)은 문자열에서 특정 규칙을 가진 데이터를 찾거나 변환하는 데 사용돼요.

📌 **정규 표현식이 사용되는 예시**

✅ 이메일 주소 검증: `"user@example.com"`이 올바른 형식인지 확인

✅ 전화번호 검사: `"010-1234-5678"` 같은 형식 찾기

✅ 특정 단어 검색: 문장에서 `"Hello"`라는 단어가 있는지 확인

✅ 비밀번호 강도 검사: 최소 8자 이상, 숫자/특수문자 포함 여부 확인

---

# **24. Java에서 정규 표현식 사용하기**

Java에서는 `java.util.regex` 패키지의 **Pattern**과 **Matcher** 클래스를 사용해 정규 표현식을 다룰 수 있어요.

## **1) 정규 표현식으로 특정 패턴 찾기**

```java
import java.util.regex.*;

public class RegexExample {
    public static void main(String[] args) {
        String text = "Hello, my number is 010-1234-5678";
        String pattern = "\\d{3}-\\d{4}-\\d{4}";  // 전화번호 형식 (000-0000-0000)

        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(text);

        if (m.find()) {
            System.out.println("전화번호를 찾았습니다: " + m.group());
        } else {
            System.out.println("전화번호가 없습니다.");
        }
    }
}
```

🔹 **실행 결과**

```
전화번호를 찾았습니다: 010-1234-5678
```

✅ `\\d{3}-\\d{4}-\\d{4}` → 숫자(3자리)-숫자(4자리)-숫자(4자리) 패턴

✅ `m.find()` → `text`에서 패턴이 있는지 검색

✅ `m.group()` → 찾은 문자열 출력

---

# **25. 정규 표현식 기초 문법**

| 표현식 | 의미 | 예제 |
| --- | --- | --- |
| `.` | 임의의 한 문자 (공백 제외) | `"a."` → `"ab"`, `"a1"` (✅) `"abc"` (❌) |
| `\d` | 숫자 (`0~9`) | `"\\d"` → `"1"`, `"5"`, `"9"` (✅) `"a"` (❌) |
| `\D` | 숫자가 아닌 문자 | `"\\D"` → `"a"`, `"#"`, `"B"` (✅) `"5"` (❌) |
| `\s` | 공백 (`스페이스, 탭, 줄바꿈`) | `"hello\sworld"` → `"hello world"` (✅) |
| `\w` | 영문자, 숫자, `_` | `"\\w"` → `"a"`, `"1"`, `"_"` (✅) `"@"` (❌) |
| `\W` | `\w`가 아닌 문자 (특수문자) | `"\\W"` → `"@"`, `"#"`, `" "` (✅) `"A"` (❌) |
| `*` | 0개 이상 반복 | `"ab*"` → `"a"`, `"ab"`, `"abb"`, `"abbbbb"` |
| `+` | 1개 이상 반복 | `"ab+"` → `"ab"`, `"abb"`, `"abbbbb"` (✅) `"a"` (❌) |
| `?` | 0개 또는 1개 | `"ab?"` → `"a"`, `"ab"` (✅) `"abb"` (❌) |
| `{n}` | 정확히 n개 반복 | `"a{3}"` → `"aaa"` (✅) `"aa"`, `"aaaa"` (❌) |
| `{n,m}` | n개 이상, m개 이하 | `"a{2,4}"` → `"aa"`, `"aaa"`, `"aaaa"` (✅) `"a"`, `"aaaaa"` (❌) |
| `^` | 문자열 시작 | `"^Hello"` → `"Hello world"` (✅) `"world Hello"` (❌) |
| `$` | 문자열 끝 | `"world$"` → `"Hello world"` (✅) `"world Hello"` (❌) |

---

# **26. 이메일 검증 (정규 표현식 활용)**

이메일 주소가 올바른 형식인지 확인하는 예제예요.

```java
import java.util.regex.*;

public class EmailValidator {
    public static void main(String[] args) {
        String email = "user@example.com";
        String pattern = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$";

        if (Pattern.matches(pattern, email)) {
            System.out.println("올바른 이메일 주소입니다.");
        } else {
            System.out.println("잘못된 이메일 형식입니다.");
        }
    }
}
```

🔹 **실행 결과**

```
올바른 이메일 주소입니다.
```

✅ `"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$"` → 이메일 형식 검증

✅ `Pattern.matches(pattern, email)` → 이메일이 패턴과 일치하는지 확인

---

# **27. 특정 패턴으로 시작하는 단어 찾기**

예를 들어 `"b"`로 시작하는 단어를 찾고 싶다면?

```java
import java.util.regex.*;

public class RegexTest {
    public static void main(String[] args) {
        String text = "bat, babe, ball, cat, car, combat";
        Pattern p = Pattern.compile("\\bb\\w+");  // 'b'로 시작하는 단어 찾기
        Matcher m = p.matcher(text);

        while (m.find()) {
            System.out.println("매칭된 단어: " + m.group());
        }
    }
}
```

🔹 **실행 결과**

```
매칭된 단어: bat
매칭된 단어: babe
매칭된 단어: ball
```

✅ `\\bb\\w+` → 단어 경계(`\b`)를 사용하여 `"b"`로 시작하는 단어 찾기

---

# **28. 정규 표현식으로 비밀번호 유효성 검사**

📌 **조건:**

- 최소 8자 이상
- 하나 이상의 숫자 포함
- 하나 이상의 대문자 포함

```java
import java.util.regex.*;

public class PasswordValidator {
    public static void main(String[] args) {
        String password = "Hello123";
        String pattern = "^(?=.*[A-Z])(?=.*\\d).{8,}$";

        if (Pattern.matches(pattern, password)) {
            System.out.println("강력한 비밀번호입니다.");
        } else {
            System.out.println("비밀번호가 약합니다.");
        }
    }
}
```

🔹 **실행 결과**

```
강력한 비밀번호입니다.
```

✅ `(?=.*[A-Z])` → 대문자 한 개 이상

✅ `(?=.*\\d)` → 숫자 한 개 이상

✅ `.{8,}` → 최소 8자 이상

---

# **29. 정리**

📌 **자주 사용하는 정규 표현식**

| 패턴 | 설명 | 예제 |
| --- | --- | --- |
| `\d{3}-\d{4}-\d{4}` | 전화번호 | `010-1234-5678` |
| `^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$` | 이메일 주소 | `user@example.com` |
| `(?=.*[A-Z])(?=.*\d).{8,}` | 강력한 비밀번호 | `Hello123` |
| `\bJava\b` | "Java"라는 단어만 검색 | `"I love Java"` |

---

# **30. 컬렉션(Collection)이란?**

컬렉션은 **여러 개의 데이터를 저장하고 조작할 수 있는 자료구조**를 제공하는 Java의 API예요.

자바 컬렉션 프레임워크는 크게 **List, Set, Map**으로 나뉘어요.

| 인터페이스 | 특징 | 예제 |
| --- | --- | --- |
| **List** | 순서 유지, 중복 허용 | `ArrayList`, `LinkedList` |
| **Set** | 순서 없음, 중복 불가 | `HashSet`, `TreeSet` |
| **Map** | 키-값(Key-Value) 쌍 저장 | `HashMap`, `TreeMap` |

---

# **31. `ArrayList` (가변 크기 배열)**

`ArrayList`는 크기가 고정된 배열(`Array`)과 달리 **자동으로 크기가 조절되는 리스트**예요.

### **1) `ArrayList` 기본 사용법**

```java
import java.util.ArrayList;

public class ArrayListExample {
    public static void main(String[] args) {
        // 리스트 생성
        ArrayList<String> list = new ArrayList<>();

        // 값 추가
        list.add("사과");
        list.add("바나나");
        list.add("체리");

        // 리스트 출력
        System.out.println("과일 리스트: " + list);
    }
}
```

🔹 **실행 결과**

```
과일 리스트: [사과, 바나나, 체리]
```

✅ `add()` → 리스트에 값 추가

✅ 리스트 크기는 자동으로 조절됨

---

### **2) 리스트에서 특정 값 가져오기 (`get()`)**

```java
System.out.println("첫 번째 과일: " + list.get(0));
```

🔹 **실행 결과**

```
첫 번째 과일: 사과
```

✅ `get(index)` → 리스트의 특정 위치 값 가져오기

---

### **3) 리스트의 크기 확인 (`size()`)**

```java
System.out.println("리스트 크기: " + list.size());
```

🔹 **실행 결과**

```
리스트 크기: 3
```

✅ `size()` → 리스트의 현재 크기 반환

---

### **4) 리스트에서 특정 값 제거 (`remove()`)**

```java
list.remove("바나나");
System.out.println("바나나 삭제 후 리스트: " + list);
```

🔹 **실행 결과**

```
바나나 삭제 후 리스트: [사과, 체리]
```

✅ `remove("값")` → 특정 요소 삭제

---

### **5) 리스트에서 반복문 사용하기**

```java
for (String fruit : list) {
    System.out.println(fruit);
}
```

🔹 **실행 결과**

```
사과
체리
```

✅ **향상된 for문**(`for-each`)을 사용하면 리스트를 쉽게 반복할 수 있어요!

---

# **32. `HashSet` (중복 없는 데이터 저장)**

`HashSet`은 **중복을 허용하지 않는 자료구조**예요.

```java
import java.util.HashSet;

public class HashSetExample {
    public static void main(String[] args) {
        HashSet<Integer> set = new HashSet<>();

        set.add(10);
        set.add(20);
        set.add(10);  // 중복 값 추가

        System.out.println("HashSet 내용: " + set);
    }
}
```

🔹 **실행 결과**

```
HashSet 내용: [10, 20]
```

✅ `HashSet`은 **중복을 허용하지 않음**

---

# **33. `HashMap` (Key-Value 저장)**

`HashMap`은 **키(Key)와 값(Value)을 저장하는 자료구조**예요.

```java
import java.util.HashMap;

public class HashMapExample {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();

        // 데이터 추가
        map.put("사과", 1000);
        map.put("바나나", 1500);
        map.put("체리", 2000);

        // 값 가져오기
        System.out.println("사과 가격: " + map.get("사과"));
    }
}
```

🔹 **실행 결과**

```
사과 가격: 1000
```

✅ `put(key, value)` → 키-값 저장

✅ `get(key)` → 특정 키의 값 가져오기

---

# **34. `TreeMap` (자동 정렬되는 Map)**

`TreeMap`은 **키를 기준으로 자동 정렬되는 `Map`**이에요.

```java
import java.util.TreeMap;

public class TreeMapExample {
    public static void main(String[] args) {
        TreeMap<Integer, String> map = new TreeMap<>();

        map.put(3, "사과");
        map.put(1, "바나나");
        map.put(2, "체리");

        System.out.println("TreeMap: " + map);
    }
}
```

🔹 **실행 결과**

```
TreeMap: {1=바나나, 2=체리, 3=사과}
```

✅ `TreeMap`은 **자동으로 Key를 정렬**

---

# **35. `Collections` 유틸리티 활용**

📌 **리스트 정렬 (`Collections.sort()`)**

```java
import java.util.ArrayList;
import java.util.Collections;

public class SortExample {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>();
        list.add(30);
        list.add(10);
        list.add(20);

        Collections.sort(list);
        System.out.println("오름차순 정렬: " + list);

        Collections.sort(list, Collections.reverseOrder());
        System.out.println("내림차순 정렬: " + list);
    }
}
```

🔹 **실행 결과**

```
오름차순 정렬: [10, 20, 30]
내림차순 정렬: [30, 20, 10]
```

✅ `Collections.sort()` → 리스트 오름차순 정렬

✅ `Collections.reverseOrder()` → 내림차순 정렬

---

# **36. 컬렉션 프레임워크 정리**

| 컬렉션 | 특징 | 주요 메서드 |
| --- | --- | --- |
| **`ArrayList`** | 순서 유지, 중복 허용 | `add()`, `get()`, `remove()`, `size()` |
| **`LinkedList`** | 삽입/삭제 빠름 | `addFirst()`, `addLast()`, `removeFirst()` |
| **`HashSet`** | 중복 제거, 순서 없음 | `add()`, `remove()`, `contains()` |
| **`TreeSet`** | 자동 정렬되는 Set | `add()`, `first()`, `last()` |
| **`HashMap`** | 키-값 저장 | `put()`, `get()`, `remove()` |
| **`TreeMap`** | 키 자동 정렬 | `put()`, `get()`, `firstKey()` |

---

# **37. 파일 입출력(File I/O)이란?**

📌 **파일 입출력은?**

- **입력(Input):** 파일에서 데이터를 읽어오는 것
- **출력(Output):** 데이터를 파일에 저장하는 것

📌 **파일 입출력 주요 클래스**

| 클래스 | 기능 |
| --- | --- |
| `File` | 파일 정보 확인 (존재 여부, 크기 등) |
| `FileWriter` | 텍스트 파일 쓰기 (출력) |
| `FileReader` | 텍스트 파일 읽기 (입력) |
| `BufferedWriter` | 버퍼를 사용하여 파일 쓰기 (성능 향상) |
| `BufferedReader` | 버퍼를 사용하여 파일 읽기 (성능 향상) |
| `FileInputStream` | 바이너리 파일 읽기 (이미지, 영상 등) |
| `FileOutputStream` | 바이너리 파일 쓰기 (이미지, 영상 등) |

---

## **38. 파일 생성 및 확인 (`File` 클래스)**

```java
import java.io.File;
import java.io.IOException;

public class FileExample {
    public static void main(String[] args) {
        File file = new File("test.txt");

        try {
            if (file.createNewFile()) {
                System.out.println("파일이 생성되었습니다.");
            } else {
                System.out.println("파일이 이미 존재합니다.");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

🔹 **실행 결과**

```
파일이 생성되었습니다.
```

✅ `file.createNewFile()` → 파일이 없으면 생성

✅ `IOException` → 입출력 오류가 발생할 수 있으므로 `try-catch` 사용

---

## **39. 파일에 데이터 쓰기 (`FileWriter`)**

```java
import java.io.FileWriter;
import java.io.IOException;

public class WriteFileExample {
    public static void main(String[] args) {
        try {
            FileWriter writer = new FileWriter("test.txt");
            writer.write("안녕하세요! 파일에 데이터를 씁니다.");
            writer.close();
            System.out.println("파일에 데이터가 저장되었습니다.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

🔹 **실행 결과**

```
파일에 데이터가 저장되었습니다.
```

✅ `write("내용")` → 파일에 문자열을 씀

✅ `close()` → 파일을 닫아야 저장됨

---

## **40. 파일에서 데이터 읽기 (`FileReader`)**

```java
import java.io.FileReader;
import java.io.IOException;

public class ReadFileExample {
    public static void main(String[] args) {
        try {
            FileReader reader = new FileReader("test.txt");
            int ch;
            while ((ch = reader.read()) != -1) {
                System.out.print((char) ch);
            }
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

🔹 **실행 결과**

```
안녕하세요! 파일에 데이터를 씁니다.
```

✅ `read()` → 파일에서 한 글자씩 읽음

✅ `-1`이 나오면 파일 끝 (EOF)

---

## **41. 파일을 한 줄씩 읽기 (`BufferedReader`)**

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedReadExample {
    public static void main(String[] args) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader("test.txt"));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

✅ `readLine()` → 한 줄씩 읽어서 출력

✅ `BufferedReader` → 성능이 더 빠름

---

## **42. 파일 복사하기 (`FileInputStream` & `FileOutputStream`)**

이미지, 동영상 같은 **바이너리 파일(2진수 데이터)**을 다룰 때 사용해요.

```java
import java.io.*;

public class FileCopyExample {
    public static void main(String[] args) {
        try {
            FileInputStream input = new FileInputStream("source.jpg");
            FileOutputStream output = new FileOutputStream("copy.jpg");

            byte[] buffer = new byte[1024];
            int length;
            while ((length = input.read(buffer)) != -1) {
                output.write(buffer, 0, length);
            }

            input.close();
            output.close();
            System.out.println("파일 복사가 완료되었습니다.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

✅ `FileInputStream` → 파일을 바이트 단위로 읽기

✅ `FileOutputStream` → 파일을 바이트 단위로 쓰기

---

# **43. 네트워크 프로그래밍이란?**

네트워크 프로그래밍은 **컴퓨터 간 데이터를 주고받는 기술**이에요.

Java는 `Socket`과 `ServerSocket`을 사용해 네트워크 통신을 구현할 수 있어요.

📌 **자주 쓰는 네트워크 API**

| 클래스 | 역할 |
| --- | --- |
| `Socket` | 클라이언트 역할 (서버에 연결) |
| `ServerSocket` | 서버 역할 (클라이언트 요청 수락) |
| `InetAddress` | IP 주소 관련 정보 처리 |

---

## **44. 간단한 서버 프로그램 (`ServerSocket`)**

```java
import java.io.*;
import java.net.*;

public class SimpleServer {
    public static void main(String[] args) {
        try {
            ServerSocket server = new ServerSocket(12345);
            System.out.println("서버가 12345번 포트에서 실행 중...");

            Socket socket = server.accept();
            System.out.println("클라이언트 연결됨!");

            BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            String message = input.readLine();
            System.out.println("클라이언트: " + message);

            input.close();
            socket.close();
            server.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

✅ `ServerSocket(12345)` → 12345번 포트에서 클라이언트 요청 대기

✅ `accept()` → 클라이언트 연결 허용

✅ `readLine()` → 클라이언트 메시지 읽기

---

## **45. 간단한 클라이언트 프로그램 (`Socket`)**

```java
import java.io.*;
import java.net.*;

public class SimpleClient {
    public static void main(String[] args) {
        try {
            Socket socket = new Socket("localhost", 12345);
            System.out.println("서버에 연결되었습니다!");

            BufferedWriter output = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
            output.write("안녕하세요, 서버!\n");
            output.flush();

            output.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

✅ `Socket("localhost", 12345)` → 서버에 연결

✅ `write("메시지")` → 서버에 메시지 전송

---

# **46. 멀티스레딩(Multithreading)이란?**

📌 **멀티스레딩(Multithreading)**은 **하나의 프로그램에서 여러 작업을 동시에 실행**하는 기술이에요.

✅ **싱글스레드(Single Thread)**: 한 번에 하나의 작업만 실행 (순차적 실행)

✅ **멀티스레드(Multi Thread)**: 여러 작업을 동시에 실행 (병렬 처리)

💡 **멀티스레딩이 필요한 경우:**

- 게임에서 **캐릭터 이동**과 **음악 재생**을 동시에 처리
- 웹 서버에서 여러 사용자의 요청을 동시에 처리
- 동영상 플레이어에서 **영상 재생**과 **자막 출력**을 동시에 실행

---

# **47. Java에서 스레드(Thread) 생성 방법**

Java에서 스레드를 만들려면 **두 가지 방법**이 있어요.

1. `Thread` 클래스를 상속받기
2. `Runnable` 인터페이스를 구현하기 (추천)

---

## **1) `Thread` 클래스를 상속받는 방법**

```java
class MyThread extends Thread {
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(getName() + " 실행 중: " + i);
            try {
                Thread.sleep(1000); // 1초 대기
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();

        t1.start();  // 스레드 실행
        t2.start();
    }
}
```

🔹 **실행 결과 (예시, 실행마다 다름)**

```
Thread-0 실행 중: 1
Thread-1 실행 중: 1
Thread-0 실행 중: 2
Thread-1 실행 중: 2
```

✅ `start()` → **스레드를 실행 (자동으로 `run()` 호출)**

✅ `sleep(1000)` → **1초 동안 멈춤**

✅ `getName()` → **스레드 이름 출력**

---

## **2) `Runnable` 인터페이스를 구현하는 방법 (추천)**

`Runnable`을 사용하면 **객체 지향 설계를 더 유연하게** 할 수 있어요.

```java
class MyRunnable implements Runnable {
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(Thread.currentThread().getName() + " 실행 중: " + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class RunnableExample {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        Thread t2 = new Thread(new MyRunnable());

        t1.start();
        t2.start();
    }
}
```

✅ `Runnable`을 사용하면 **다중 상속 문제를 피할 수 있어 더 유연함**

---

# **48. 멀티스레딩에서 발생하는 문제 (동기화 문제)**

여러 스레드가 **동시에 같은 데이터를 수정할 때** 오류가 발생할 수 있어요.

```java
class Counter {
    private int count = 0;

    public void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class RaceConditionExample {
    public static void main(String[] args) {
        Counter counter = new Counter();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) counter.increment();
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) counter.increment();
        });

        t1.start();
        t2.start();

        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("최종 카운트: " + counter.getCount()); // 예상: 2000, 실제: ???
    }
}
```

🔹 **문제점**

- `count` 변수를 두 개의 스레드가 동시에 변경하면서 값이 올바르게 증가하지 않을 수 있음.

---

## **49. `synchronized`를 사용해 동기화 문제 해결**

```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
```

✅ `synchronized` 키워드를 사용하면 **한 번에 하나의 스레드만 메서드를 실행할 수 있음**

---

# **50. `ExecutorService`를 이용한 스레드 풀(Thread Pool)**

스레드를 직접 관리하면 **자원 낭비**가 발생할 수 있어요.

그래서 Java에서는 `ExecutorService`를 사용해 **스레드를 미리 만들어두고 재사용**할 수 있어요.

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3); // 스레드 3개

        for (int i = 1; i <= 10; i++) {
            final int taskNumber = i;
            executor.execute(() -> {
                System.out.println("작업 " + taskNumber + " 실행 (스레드: " + Thread.currentThread().getName() + ")");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }

        executor.shutdown(); // 작업 완료 후 종료
    }
}
```

🔹 **실행 결과 (예시)**

```
작업 1 실행 (스레드: pool-1-thread-1)
작업 2 실행 (스레드: pool-1-thread-2)
작업 3 실행 (스레드: pool-1-thread-3)
...
```

✅ `Executors.newFixedThreadPool(3)` → **스레드 3개만 사용**

✅ `execute()` → **작업을 실행할 스레드에 전달**

✅ `shutdown()` → **모든 작업 완료 후 종료**

---

# **51. Java 멀티스레딩 요약**

| 개념 | 설명 |
| --- | --- |
| `Thread` | 직접 상속하여 스레드 생성 |
| `Runnable` | 인터페이스 구현 (추천) |
| `synchronized` | 동기화 처리 (경쟁 조건 해결) |
| `ExecutorService` | 스레드 풀 사용 (자원 효율적 사용) |

---

---

# **52. JDBC(Java Database Connectivity)란?**

📌 **JDBC는 Java에서 데이터베이스에 연결하는 표준 API**

✅ **데이터 조회(SELECT)**

✅ **데이터 삽입(INSERT)**

✅ **데이터 수정(UPDATE)**

✅ **데이터 삭제(DELETE)**

---

# **53. JDBC 설정하기 (MySQL 연동)**

MySQL과 Java를 연결하려면 **JDBC 드라이버**가 필요해요.

### **1) MySQL JDBC 드라이버 다운로드**

👉 [MySQL Connector/J 다운로드](https://dev.mysql.com/downloads/connector/j/)

### **2) JDBC 드라이버 추가 (Maven 프로젝트)**

`pom.xml` 파일에 **MySQL JDBC 드라이버 추가**

```xml
<dependencies>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.33</version>  <!-- 최신 버전 확인 -->
    </dependency>
</dependencies>
```

### **3) 데이터베이스 연결 정보**

MySQL에 연결할 때 필요한 정보:

```
JDBC URL: jdbc:mysql://localhost:3306/mydatabase
사용자 이름: root
비밀번호: 1234
```

---

# **54. Java에서 MySQL 연결하기**

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class MySQLConnection {
    public static void main(String[] args) {
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String user = "root";
        String password = "1234";

        try {
            Connection conn = DriverManager.getConnection(url, user, password);
            System.out.println("데이터베이스 연결 성공!");
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

✅ `DriverManager.getConnection()` → 데이터베이스 연결

✅ `conn.close()` → 연결 종료

---

# **55. 데이터 조회(SELECT)**

```java
import java.sql.*;

public class SelectExample {
    public static void main(String[] args) {
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String user = "root";
        String password = "1234";

        try {
            Connection conn = DriverManager.getConnection(url, user, password);
            String sql = "SELECT * FROM users";
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(sql);

            while (rs.next()) {
                int id = rs.getInt("id");
                String name = rs.getString("name");
                String email = rs.getString("email");
                System.out.println("ID: " + id + ", 이름: " + name + ", 이메일: " + email);
            }

            rs.close();
            stmt.close();
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

✅ `executeQuery(sql)` → SELECT 실행

✅ `rs.next()` → 결과 행을 하나씩 가져오기

✅ `getInt("id")` / `getString("name")` → 데이터 가져오기

---

# **56. 데이터 삽입(INSERT)**

```java
import java.sql.*;

public class InsertExample {
    public static void main(String[] args) {
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String user = "root";
        String password = "1234";

        try {
            Connection conn = DriverManager.getConnection(url, user, password);
            String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
            PreparedStatement pstmt = conn.prepareStatement(sql);

            pstmt.setString(1, "홍길동");
            pstmt.setString(2, "hong@example.com");

            int rows = pstmt.executeUpdate();
            if (rows > 0) {
                System.out.println("데이터 삽입 성공!");
            }

            pstmt.close();
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

✅ `PreparedStatement` → SQL 인젝션 방지 (보안 강화)

✅ `executeUpdate()` → 데이터 변경(INSERT, UPDATE, DELETE) 수행

---

# **57. 데이터 수정(UPDATE)**

```java
String sql = "UPDATE users SET email = ? WHERE name = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1, "hong_new@example.com");
pstmt.setString(2, "홍길동");
```

✅ 특정 사용자의 이메일을 변경

---

# **58. 데이터 삭제(DELETE)**

```java
String sql = "DELETE FROM users WHERE name = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1, "홍길동");
```

✅ 특정 사용자의 데이터를 삭제

---

# **59. 트랜잭션(Transaction) 처리**

트랜잭션은 **여러 개의 SQL 작업을 하나의 작업처럼 실행하는 기능**이에요.

```java
conn.setAutoCommit(false);  // 트랜잭션 시작

try {
    String sql1 = "UPDATE accounts SET balance = balance - 500 WHERE id = 1";
    String sql2 = "UPDATE accounts SET balance = balance + 500 WHERE id = 2";

    Statement stmt = conn.createStatement();
    stmt.executeUpdate(sql1);
    stmt.executeUpdate(sql2);

    conn.commit();  // 모든 작업 성공 시 저장
    System.out.println("송금 완료!");
} catch (SQLException e) {
    conn.rollback();  // 오류 발생 시 원래 상태로 되돌리기
    e.printStackTrace();
}
```

✅ `setAutoCommit(false)` → 수동 커밋 모드 설정

✅ `commit()` → 변경사항 저장

✅ `rollback()` → 오류 발생 시 원래 상태로 복구

---

# **60. JDBC + DAO 패턴 사용 (객체지향 프로그래밍)**

DAO(Data Access Object)를 사용하면 **데이터베이스 코드를 분리**할 수 있어요.

### **1) `UserDAO` 클래스 (데이터베이스 연결 및 쿼리 실행)**

```java
import java.sql.*;

public class UserDAO {
    private Connection conn;

    public UserDAO() throws SQLException {
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String user = "root";
        String password = "1234";
        conn = DriverManager.getConnection(url, user, password);
    }

    public void addUser(String name, String email) throws SQLException {
        String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
        PreparedStatement pstmt = conn.prepareStatement(sql);
        pstmt.setString(1, name);
        pstmt.setString(2, email);
        pstmt.executeUpdate();
        pstmt.close();
    }

    public void close() throws SQLException {
        conn.close();
    }
}
```

### **2) `Main` 클래스 (실제 사용)**

```java
public class Main {
    public static void main(String[] args) {
        try {
            UserDAO dao = new UserDAO();
            dao.addUser("이순신", "lee@example.com");
            System.out.println("사용자 추가 완료!");
            dao.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

✅ DAO 패턴을 사용하면 **코드가 더 깔끔해지고 유지보수가 쉬워짐**

---

---

# **61. Spring Framework란?**

📌 **Spring은 Java 웹 애플리케이션 개발을 쉽게 해주는 프레임워크**

✅ **웹 서버 구축 가능** (`Spring Boot`)

✅ **데이터베이스 연동 가능** (`Spring Data JPA`)

✅ **REST API 개발 가능** (`Spring Web`)

✅ **의존성 관리 편리** (`Spring Boot Starter`)

---

# **62. Spring Boot 프로젝트 설정**

Spring Boot는 **Spring을 쉽게 설정하고 실행할 수 있도록 도와주는 프레임워크**예요.

📌 **Spring Boot 프로젝트 생성 방법**

1. [Spring Initializr](https://start.spring.io/)에서 프로젝트 생성
2. `Spring Web`, `Spring Boot DevTools`, `Lombok`, `Spring Data JPA`, `MySQL Driver` 선택
3. 다운로드 후 **Maven 프로젝트 실행**

📌 **Maven `pom.xml`에 필요한 라이브러리 추가**

```xml
<dependencies>
    <!-- Spring Boot 기본 라이브러리 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- 데이터베이스 (JPA + MySQL) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
</dependencies>
```

📌 **Spring Boot 실행**

터미널에서 다음 명령어 실행

```bash
mvn spring-boot:run
```

✅ 서버가 실행되면 **http://localhost:8080**에서 확인 가능

---

# **63. Spring Boot에서 REST API 만들기**

REST API는 **클라이언트(React, Vue, Android)와 서버(Spring Boot) 간 데이터를 주고받는 방식**이에요.

---

## **1) `Hello World` API 만들기**

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "Hello, Spring Boot!";
    }
}
```

✅ `@RestController` → REST API를 만들 때 사용

✅ `@RequestMapping("/api")` → 기본 URL 설정

✅ `@GetMapping("/hello")` → **GET 요청을 처리하는 API**

📌 **실행 후 브라우저에서 확인**

👉 **http://localhost:8080/api/hello**

```
Hello, Spring Boot!
```

---

## **2) JSON 데이터를 반환하는 API 만들기**

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api")
public class UserController {

    @GetMapping("/user")
    public Map<String, String> getUser() {
        Map<String, String> user = new HashMap<>();
        user.put("name", "홍길동");
        user.put("email", "hong@example.com");
        return user;
    }
}
```

✅ JSON 데이터를 반환하려면 **Map 또는 DTO 객체 사용**

📌 **실행 후 브라우저에서 확인**

👉 **http://localhost:8080/api/user**

```json
{
    "name": "홍길동",
    "email": "hong@example.com"
}
```

---

# **64. Spring Boot에서 데이터베이스 연동**

Spring Boot에서 데이터베이스(MySQL)를 사용하려면 **JPA**를 사용하면 좋아요.

JPA는 SQL 없이 데이터베이스를 쉽게 다룰 수 있도록 도와주는 기술이에요.

---

## **1) 데이터베이스 설정 (application.properties)**

📌 `src/main/resources/application.properties`

```
spring.datasource.url=jdbc:mysql://localhost:3306/mydatabase
spring.datasource.username=root
spring.datasource.password=1234
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

✅ `ddl-auto=update` → 자동으로 테이블 생성

---

## **2) 엔터티(Entity) 만들기**

```java
import jakarta.persistence.*;

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;

    // 기본 생성자 & Getter/Setter
    public User() {}
    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }
    public Long getId() { return id; }
    public String getName() { return name; }
    public String getEmail() { return email; }
}
```

✅ `@Entity` → 데이터베이스 테이블과 매핑

✅ `@Id` → 기본 키(PK) 설정

✅ `@GeneratedValue` → 자동 증가(AUTO_INCREMENT)

---

## **3) 데이터베이스 저장소 (Repository) 만들기**

```java
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {
}
```

✅ `JpaRepository<User, Long>` → 자동으로 CRUD 기능 제공

---

## **4) REST API (사용자 추가 및 조회)**

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api")
public class UserController {
    @Autowired
    private UserRepository userRepository;

    // 모든 사용자 조회
    @GetMapping("/users")
    public List<User> getUsers() {
        return userRepository.findAll();
    }

    // 새로운 사용자 추가
    @PostMapping("/users")
    public User createUser(@RequestBody User user) {
        return userRepository.save(user);
    }
}
```

✅ `@GetMapping("/users")` → 모든 사용자 조회

✅ `@PostMapping("/users")` → 새 사용자 추가

📌 **테스트 방법**

1. **GET 요청**: 모든 사용자 조회
    
    👉 **http://localhost:8080/api/users**
    
2. **POST 요청**: 새 사용자 추가 (JSON 데이터 전송)
    
    ```json
    {
        "name": "이순신",
        "email": "lee@example.com"
    }
    ```
    
    👉 `Postman` 또는 `cURL` 사용
    

---

# **65. Spring Boot REST API 정리**

| 기능 | 설명 |
| --- | --- |
| `@RestController` | REST API를 제공하는 컨트롤러 |
| `@RequestMapping("/api")` | 기본 URL 설정 |
| `@GetMapping("/users")` | GET 요청 처리 (조회) |
| `@PostMapping("/users")` | POST 요청 처리 (데이터 추가) |
| `@Autowired` | 의존성 주입 |
| `JpaRepository<User, Long>` | 데이터베이스 자동 관리 |

---

이제 **Spring Boot를 활용한 REST API 개발**을 자유롭게 할 수 있어요! 🎉

다음으로 **Spring Security(인증 & 로그인), OAuth, JWT, 배포(Docker, AWS)**도 설명해 줄까요? 🚀
