---
layout: post
title: "CHAP 6.  성능 튜닝 및 GC 최적화 전략"
date: 2025-06-10
categories: [backend, backend-fw, mvc2]
tags: [backend, backend-fw, mvc2]
thumbnail: /assets/img/post-thumbnails/intro7.png
author: Devchanny
---


# ** 📌 PART 6.1 JSP 프로젝트에서의 메모리 튜닝 항목 **

> "서버가 버벅이지 않고, 빠르게 동작하면서 메모리도 안정적으로 쓰게 만드는 방법"
> 

---

### 🟢 1단계. 톰캣 서버에서 메모리는 어디에 쓰일까?

> 💬 JSP 프로젝트는 웹 서버(Tomcat)가 작동하면서
> 
> 
> 여러 파일(JSP, 클래스, 세션 등)을 **메모리(RAM)** 에 적재해서 처리해.
> 

---

### ✅ 메모리 쓰이는 대표 예시

| 항목 | 설명 |
| --- | --- |
| JSP 서블릿 코드 | JSP → Servlet 변환된 코드가 메모리에 올라감 |
| 세션(Session) | 로그인 정보 등 사용자별 상태 저장 |
| 자바 객체 | 컨트롤러, DAO, DTO 등 클래스 인스턴스 |
| 파일 처리 | 업로드된 이미지/파일 정보 |
| GC 대상 객체 | 더 이상 사용하지 않는 객체들 (메모리 누수 주의) |

---

## 🔧 2단계. JVM 메모리 옵션으로 서버 성능 튜닝하기

> 💬 JVM(Java Virtual Machine)은 자바 코드가 실행되는 가상 환경이야.
> 
> 
> Tomcat도 JVM 위에서 돌아가기 때문에 **메모리 크기를 직접 설정**할 수 있어!
> 

---

### ✅ 대표 JVM 옵션 설명

| 옵션 | 설명 | 비유 |
| --- | --- | --- |
| `-Xms` | JVM이 시작할 때 확보할 최소 메모리 | 서버가 처음에 차지할 책상 크기 |
| `-Xmx` | 최대 사용할 수 있는 메모리 | 책상을 아무리 써도 넘지 못할 최대 크기 |
| `-XX:+UseG1GC` | G1 Garbage Collector 사용 | 똑똑하고 빠르게 정리해주는 청소부 |
| `-XX:MaxPermSize` (구버전) | 클래스/메서드 정보 저장 영역 크기 | 📚 교재함 크기 (Java 8 이전) |

---

### ✅ 실무 예시: Tomcat 실행 옵션

```bash
JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC"
```

→ 처음엔 512MB, 최대 1GB 메모리 사용 / G1 GC 사용

---

### 💡 중학생도 이해하는 GC (가비지 컬렉터) 설명

> GC는 자바 프로그램이 쓰고 나서 더 이상 필요 없는 쓰레기 객체를 자동으로 치워주는 기능이야!
> 

### 예시:

- `new String("hello")` 만들고 → 참조 없으면 → GC가 정리해줌!
- 근데 그 쓰레기가 너무 많으면 → GC가 너무 자주 일함 → 성능 느려짐 → 서버 버벅임

---

## 🚀 3단계. GC 전략 중 G1GC가 좋은 이유

| GC 종류 | 특징 |
| --- | --- |
| **Serial GC** | 단일 쓰레드로 처리 → 느림 |
| **Parallel GC** | 멀티 쓰레드 사용 → 성능 좋음 (기본) |
| **G1GC** | **작은 영역 단위로 나눠서 정리**함 → **응답 지연 적고, 메모리 안정성 최고** |

---

### ✅ G1GC 특징

- 큰 객체 하나가 아니라, 작은 "영역(region)" 단위로 청소함
- Full GC가 적게 발생함
- 서버 응답 시간이 안정적임 → **JSP 서버에 매우 적합!**

---

## 🧠 4단계. JSP precompile 전략과 메모리 절약

---

### 💬 JSP는 처음 요청할 때 느리다?

> JSP는 서버에서 처음 요청이 들어왔을 때만
> 
> 
> → `.jsp` 파일을 `.java` → `.class`로 변환해서 실행돼.
> 

### 이 과정:

- 변환 → 컴파일 → 클래스 로딩
    
    → 메모리 사용량 많고, **응답 시간 느림**
    

---

### ✅ Precompile(미리 컴파일) 전략이란?

> JSP 파일을 미리 서블릿(.class)으로 만들어놔서
> 
> 
> **첫 요청 때 버벅이지 않게** 준비하는 전략!
> 

---

### 📦 JSP Precompile 효과

| 항목 | 효과 |
| --- | --- |
| JSP 컴파일 타이밍 | 최초 요청 → 배포 시로 변경됨 |
| 성능 ↑ | 첫 사용자 요청 시간 단축 |
| 메모리 ↓ | 컴파일 과정에서 불필요한 객체 생성 줄어듦 |
| GC 효율 ↑ | 요청 시마다 클래스 생성/삭제 발생 안 함 |

---

### ✅ Precompile 방법 (Tomcat 예시)

```bash
cd $CATALINA_HOME/bin
jspc -d /output/path /webapp/**/*.jsp
```

또는 Maven + Jetty/Tomcat 플러그인 사용 가능

---

## 🎓 5단계. 면접 포인트 정리

| 질문 | 모범 답변 요약 |
| --- | --- |
| JVM 옵션 -Xms와 -Xmx 차이는? | 시작 시 메모리와 최대 메모리 크기를 설정하는 옵션입니다 |
| G1GC는 어떤 상황에서 좋나요? | 대규모 서버에서 짧은 응답시간을 유지해야 할 때 좋습니다 |
| JSP precompile이란? | JSP를 서버 시작 시 미리 컴파일해서 초기 로딩을 빠르게 만드는 전략입니다 |
| JSP가 많을 때 메모리 문제가 생기나요? | 네, 많은 JSP가 동시에 변환되면 클래스 로딩으로 메모리 압박이 커집니다 |
| 톰캣에서 Full GC가 자주 발생하면 어떻게 하나요? | 메모리 옵션 조정 + GC 종류 변경 + JSP precompile 전략을 병행합니다 |

---

## ✅ 마무리 요약표

| 항목 | 설명 | 메모리 영향 |
| --- | --- | --- |
| `-Xms` | JVM 시작 시 확보할 메모리 | 너무 작으면 GC 자주 발생 |
| `-Xmx` | JVM 최대 메모리 제한 | 서버가 사용할 수 있는 최대 공간 |
| `UseG1GC` | G1 가비지 컬렉터 사용 | 안정적이고 빠른 메모리 정리 |
| JSP precompile | JSP 미리 컴파일 | 첫 요청 시간 ↓, 메모리 효율 ↑ |


✅ PART 6.2 GC 로그 분석을 통한 메모리 병목 추적

> "서버가 느려지면 가비지 컬렉터(GC) 탓일 수도 있어요!"
> 

---

### 🟢 1단계. GC(가비지 컬렉션)가 뭐야?

> 💬 GC는 자바가 안 쓰는 메모리를 정리해주는 똑똑한 청소기야!
> 

### 예시:

```java
String name = new String("홍길동");
// 이 name을 더 이상 안 쓰면 → GC가 알아서 치워줌!
```

---

### ✅ 그런데 문제는?

> 이 GC가 청소를 너무 자주 하거나, 한 번 할 때 오래 걸리면…
> 
> 
> 💥 **웹사이트가 멈춘 것처럼 느려질 수 있어!**
> 

---

## 🔥 2단계. Full GC가 뭐고 왜 위험할까?

### ✅ GC는 종류가 2가지 있어

| 종류 | 설명 | 속도 |
| --- | --- | --- |
| **Young GC** | 짧게 짧게 자주 청소함 | 빠름 |
| **Full GC** | 전체 메모리를 정리함 (Old 영역까지) | 느림! 서버 잠깐 멈춤 💀 |

---

### 💡 Full GC가 발생하면?

- 서버가 그 순간에는 **다른 작업을 멈춤 (Stop The World)**
- 사용자 요청 응답이 **잠시 멈춤 or 실패**
- 페이지가 느려지거나 서버가 다운되는 것처럼 보임

---

### ✅ 예시 (중학생도 이해 가능한 흐름)

```
[사용자 요청]
→ 페이지 열림
→ 갑자기 서버가 "잠깐만~ GC 좀 하고 올게"
→ Full GC 중...
→ 사용자 입장: "왜 이렇게 느려?! 안 뜨네?"
```

---

## 📜 3단계. GC 로그 켜기 + Full GC 확인 방법

---

### ✅ Tomcat JVM 옵션에서 GC 로그 활성화

```bash
-verbose:gc
-Xlog:gc*:file=logs/gc.log:time,uptime,level,tags
```

> 💡 이걸 설정하면 gc.log 파일에 GC가 실행된 시간, 종류, 소요 시간 등이 저장됨
> 

---

### ✅ GC 로그 예시

```bash
[Full GC (System.gc())  1024M->512M(2048M), 1.2345678 secs]
```

| 항목 | 의미 |
| --- | --- |
| `Full GC` | 전체 영역 정리 발생 |
| `1024M->512M` | 정리 전 1024MB → 정리 후 512MB |
| `1.23 secs` | GC에 1.23초 걸림 😱 (위험 신호!) |

---

## 🧠 4단계. Full GC가 자주 발생하는 이유는?

| 원인 | 설명 |
| --- | --- |
| 너무 많은 객체 생성 | 예: 반복문 안에서 new 객체 생성 무한 |
| 큰 객체 유지 | 예: 큰 이미지 리스트를 세션에 계속 유지 |
| 메모리 부족 | -Xmx 설정이 너무 작음 |
| GC 설정 부적절 | G1GC 안 쓰고, 기본 Serial GC일 경우 발생률 ↑ |

---

### 💡 실무에서 있었던 실제 문제 사례

> 팀에서 만든 쇼핑몰이 느려졌는데 이유를 몰랐음.
> 
> 
> GC 로그를 봤더니 Full GC가 5초 간격으로 계속 발생 중…
> 
> 알고 보니, 세션에 상품 전체 리스트를 통째로 저장하고 있었음! 😱
> 

---

## 🎯 5단계. 면접 포인트 총정리

| 질문 | 모범 답변 요약 |
| --- | --- |
| Full GC가 자주 발생하면 어떤 문제가 생기나요? | 서버가 그 순간 모든 작업을 멈추기 때문에 사용자 요청이 지연되거나 실패할 수 있습니다 |
| GC 로그는 어떻게 확인하나요? | JVM 옵션에서 `-Xlog:gc*` 설정을 통해 `gc.log` 파일로 저장할 수 있습니다 |
| Full GC가 발생하는 이유는? | 객체 생성 과다, 메모리 부족, 잘못된 GC 설정 등이 있습니다 |
| 해결 방법은? | G1GC 설정, 객체 재사용, 세션 메모리 최소화, 메모리 증가(-Xmx 조절) 등 |
| 실무에서 GC 병목을 어떻게 잡나요? | GC 로그 시각화 도구(GCViewer, VisualVM 등)로 분석하고 튜닝합니다 |

---

## ✅ 마무리 요약표

| 항목 | 설명 | 메모리 영향 |
| --- | --- | --- |
| Full GC | 전체 메모리 정리 (Old 영역 포함) | 서버 응답 지연 ↑, GC 시간 ↑ |
| GC 로그 | GC 동작 시간/결과 확인 도구 | 병목 추적 가능 |
| 병목 원인 | 객체 과다 생성, 메모리 부족 | 해결 없으면 서버 느려짐/중단 |
| 튜닝 전략 | G1GC 사용, -Xmx 증가, 객체 수명 조절 | GC 횟수 ↓, 서버 안정성 ↑ |
