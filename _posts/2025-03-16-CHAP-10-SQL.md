---
layout: devchannyp
title: "CHAP 10. 트랜잭션 및 동시성 제어 "
date: 2025-03-16
categories: sql
tags: [MariaDB, SQL, DBMS]
---
# 📌 안전한 데이터 처리

데이터베이스 시스템에서 **트랜잭션**과 **동시성 제어**는 데이터의 무결성과 일관성을 유지하기 위한 핵심 개념입니다. 이를 이해하고 적절히 활용하는 것은 안정적인 데이터 처리를 위해 필수적입니다.

---

## **1. 트랜잭션과 ACID 원칙**

### 🎯 **트랜잭션(Transaction)이란?**

트랜잭션은 데이터베이스에서 하나의 논리적 작업 단위를 의미하며, 여러 개의 데이터베이스 연산을 하나의 작업 단위로 묶어 처리합니다. 트랜잭션은 모두 성공적으로 완료되거나, 모두 실패하여 이전 상태로 복구되어야 합니다. 

### 🎯 **ACID 원칙**

트랜잭션은 다음의 ACID 원칙을 따라야 합니다:

1. **원자성(Atomicity):** 트랜잭션의 모든 연산은 모두 성공적으로 완료되거나, 모두 실패하여 이전 상태로 복구되어야 합니다.
2. **일관성(Consistency):** 트랜잭션이 성공적으로 완료되면 데이터베이스는 일관성 있는 상태를 유지해야 합니다.[j-](https://velog.io/%40youngerjesus/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction)
3. **격리성(Isolation):** 동시에 실행되는 트랜잭션들은 서로 간섭하지 않도록 독립적으로 수행되어야 합니다.
4. **지속성(Durability):** 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 데이터베이스에 반영되어야 합니다.

---

## 🎯 **트랜잭션의 상태**

트랜잭션은 수행 과정에서 다음과 같은 상태를 가집니다:

1. **활성 상태 (Active)**
    - 트랜잭션이 시작되어 연산이 실행 중인 상태입니다.
2. **부분 완료 상태 (Partially Committed)**
    - 트랜잭션의 모든 연산이 실행을 완료하고, Commit 연산이 도착한 상태입니다.
3. **완료 상태 (Committed)**
    - 트랜잭션이 성공적으로 완료되어 그 결과가 데이터베이스에 영구적으로 저장된 상태입니다.
4. **실패 상태 (Failed)**
    - 트랜잭션이 실행 도중 오류가 발생하여 더 이상 진행할 수 없는 상태입니다.
5. **철회 상태 (Aborted)**
    - 트랜잭션이 실패하여 Rollback 연산을 통해 시작 전 상태로 복구된 상태입니다.

---

## 📚 **2. 트랜잭션 격리 수준**

여러 트랜잭션이 동시에 실행될 때 발생할 수 있는 데이터 불일치 문제를 방지하기 위해, 데이터베이스는 트랜잭션 격리 수준을 제공합니다. SQL 표준에서는 다음과 같은 4가지 격리 수준을 정의합니다

1. **READ UNCOMMITTED (커밋되지 않은 읽기):**
    - 트랜잭션이 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있습니다.
    - **문제점:** Dirty Read, Non-repeatable Read, Phantom Read 발생 가능성이 있습니다.
2. **READ COMMITTED (커밋된 읽기):**
    - 트랜잭션이 커밋된 데이터만 읽을 수 있습니다.
    - **문제점:** Non-repeatable Read, Phantom Read 발생 가능성이 있습니다.
3. **REPEATABLE READ (반복 가능한 읽기):**
    - 트랜잭션이 동일한 데이터를 여러 번 읽어도 동일한 결과를 보장합니다.
    - **문제점:** Phantom Read 발생 가능성이 있습니다.
4. **SERIALIZABLE (직렬화 가능):**
    - 가장 높은 수준의 격리로, 트랜잭션들이 순차적으로 실행되는 것처럼 동작합니다.
    - **문제점:** 동시성 처리 성능이 저하될 수 있습니다.

---

## **3. 동시성 제어와 MVCC**

### 🎯 **동시성 제어(Concurrency Control)**

**동시성 제어**는 다중 사용자 환경에서 여러 트랜잭션이 동시에 수행될 때, 데이터의 **일관성**과 **무결성**을 유지하기 위한 기법입니다. 동시성 제어가 없다면 다음과 같은 문제가 발생할 수 있습니다

- **갱신 손실 (Lost Update)**
    - 두 개의 트랜잭션이 동일한 데이터를 동시에 갱신할 때, 한 트랜잭션의 갱신 결과가 다른 트랜잭션에 의해 덮어쓰여지는 현상입니다.
- **현황 파악 오류 (Dirty Read)**
    - 한 트랜잭션이 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽을 때 발생하는 문제입니다.
- **반복 불가능한 읽기 (Non-repeatable Read)**
    - 한 트랜잭션이 같은 데이터를 두 번 읽을 때, 그 사이에 다른 트랜잭션이 해당 데이터를 수정하거나 삭제하여 결과가 달라지는 현상입니다.
- **팬텀 리드 (Phantom Read)**
    - 한 트랜잭션이 특정 조건으로 데이터를 조회한 후, 다른 트랜잭션이 해당 조건에 맞는 새로운 데이터를 삽입하여 이전 트랜잭션이 동일한 조회를 했을 때 결과 집합이 달라지는 현상입니다.

### 🎯 **MVCC(Multi-Version Concurrency Control)**

MVCC는 데이터베이스에서 동시성 제어를 위해 사용되는 기법으로, 각 트랜잭션이 데이터의 스냅샷을 가져와 작업을 수행하게 함으로써 읽기 작업과 쓰기 작업이 충돌하지 않도록 합니다. 이를 통해 데이터베이스의 동시성을 높이고, 잠금으로 인한 병목 현상을 줄일 수 있습니다.

---

## **4. 데드락(Deadlock)과 해결 방법**

### 🎯 **데드락(Deadlock)이란?**

데드락은 두 개 이상의 트랜잭션이 서로가 소유한 자원을 기다리며 무한 대기 상태에 빠지는 현상을 말합니다. 이러한 상황이 발생하면 트랜잭션이 진행되지 못하고 시스템의 성능이 저하됩니다.

### 🎯 **데드락 해결 방법**

1. **예방(Prevention):** 트랜잭션이 자원을 요청할 때 데드락이 발생하지 않도록 미리 방지하는 방법입니다. 예를 들어, 모든 트랜잭션이 자원을 동일한 순서로 요청하도록 규칙을 정할 수 있습니다.

📌  **그러나,** 이는 현실적으로 비효율적일 수 있으므로, 트랜잭션들이 자원에 접근하는 순서를 일관되게 유지하거나, 트랜잭션을 자주 커밋하는 등의 방법이 데드락 예방에 도움이 될 수 있습니다.

1. **회피(Avoidance):** 트랜잭션이 자원을 요청할 때 현재 상태를 고려하여 데드락이 발생할 가능성이 있는지 판단하고, 발생할 가능성이 있으면 자원 할당을 보류하는 방법입니다.

📌 **시간 스탬프**를 활용하여 교착 상태를 회피하는 방법으로, Wait-Die 방식과 Wound-Wait 방식이 있습니다. Wait-Die 방식은 오래된 트랜잭션이 자원을 요청하면 대기하고, 새로운 트랜잭션이 자원을 요청하면 포기하는 방식입니다. 반면, Wound-Wait 방식은 오래된 트랜잭션이 자원을 요청하면 자원을 선점하고, 새로운 트랜잭션이 자원을 요청하면 대기하는 방식입니다.

1. **탐지(Detection) 및 복구(Recovery):** 데드락이 발생했는지 주기적으로 검사하고, 발견되면 일부 트랜잭션을 중단(rollback)하여 데드락 상태를 해소하는 방법입니다.

---

## 🔥**5. 잠금(Lock) 메커니즘**

## ✅1. 잠금의 기본 개념

잠금은 트랜잭션이 특정 데이터에 접근하거나 수정할 때, 다른 트랜잭션이 해당 데이터에 동시에 접근하거나 수정하지 못하도록 제한하는 메커니즘입니다. 이를 통해 데이터의 무결성을 유지하고, 여러 트랜잭션이 동시에 같은 데이터를 수정하려 할 때 발생할 수 있는 충돌을 방지합니다.

## ✅2. 잠금의 유형

잠금은 기능과 목적에 따라 여러 유형으로 분류됩니다.

### a. 공유 잠금(Shared Lock, S Lock)

공유 잠금은 여러 트랜잭션이 동시에 데이터를 읽을 수 있도록 허용합니다. 그러나 공유 잠금이 걸린 데이터에 대해 다른 트랜잭션이 수정하려면, 해당 공유 잠금이 해제될 때까지 대기해야 합니다. 이는 데이터를 읽는 동안 다른 트랜잭션이 데이터를 변경할 수 없도록 하여 데이터의 일관성을 보장합니다.

### b. 배타 잠금(Exclusive Lock, X Lock)

배타 잠금은 데이터를 수정하거나 삭제하려는 트랜잭션에 부여됩니다. 배타 잠금을 획득한 트랜잭션 외에는 해당 데이터에 대한 다른 잠금을 요청할 수 없으며, 다른 트랜잭션은 데이터를 읽거나 수정할 수 없습니다. 이를 통해 트랜잭션이 데이터를 안전하게 수정할 수 있도록 보장합니다.

### c. 낙관적 잠금(Optimistic Lock)

데이터베이스 수준에서의 잠금이 아닌, 애플리케이션 수준에서 버전 관리 등을 통해 동시성 문제를 해결하는 방법입니다. 이는 트랜잭션이 충돌하지 않을 것이라고 가정하고, 커밋 시점에 충돌 여부를 확인하여 문제가 있을 경우 롤백하는 방식입니다. 이러한 방식은 충돌이 드물게 발생하는 시나리오에서 성능상의 이점을 제공합니다

## ✅3. 잠금의 세분화(Granularity)

잠금은 적용 범위에 따라 세분화됩니다.

### 🔹a. 행 수준 잠금(Row-Level Lock)

특정 행에 대해 잠금을 설정합니다. 이는 높은 동시성을 제공하지만, 잠금 관리 오버헤드가 큽니다.

### 🔹b. 페이지 수준 잠금(Page-Level Lock)

데이터베이스 페이지 단위로 잠금을 설정합니다. 이는 행 수준과 테이블 수준의 중간 정도의 동시성을 제공합니다.

### 🔹c. 테이블 수준 잠금(Table-Level Lock)

전체 테이블에 대해 잠금을 설정합니다. 이는 잠금 관리가 간단하지만, 동시성이 낮아질 수 있습니다.

### 🔹d. 데이터베이스 수준 잠금(Database-Level Lock)

전체 데이터베이스에 대해 잠금을 설정합니다. 이는 주로 관리 작업 시 사용되며, 동시성이 매우 낮아집니다.

## ✅4. 잠금의 구현 및 관리

잠금은 데이터베이스 시스템에서 자동으로 관리되지만, 개발자는 잠금의 동작 방식을 이해하고, 필요에 따라 명시적으로 잠금을 제어할 수 있습니다. 예를 들어, 트랜잭션 격리 수준을 설정하거나, 특정 쿼리에 대해 명시적으로 잠금을 설정할 수 있습니다.

## ✅5. 잠금과 성능

잠금은 데이터 무결성을 유지하는 데 필수적이지만, 과도한 잠금이나 부적절한 잠금 관리로 인해 성능 저하가 발생할 수 있습니다. 따라서 잠금의 유형과 범위를 적절하게 설정하고, 트랜잭션을 신속하게 처리하여 잠금이 장시간 유지되지 않도록 하는 것이 중요합니다.

**📌 잠금 경합(Lock Contention)**: 여러 트랜잭션이 동시에 동일한 자원에 대해 잠금을 요청할 때 발생하는 경합 상황은 시스템 성능에 부정적인 영향을 미칠 수 있습니다. 이를 최소화하기 위해 트랜잭션의 범위를 최소화하고, 필요한 자원에만 잠금을 설정하며, 트랜잭션을 신속하게 처리하는 것이 중요합니다.

## 🎯 분산 환경에서의 잠금 관리

**분산 잠금(Distributed Lock)**: 여러 대의 서버가 분산 환경에서 동일한 자원에 접근할 때 동시성 문제를 해결하기 위해 분산 잠금 메커니즘이 사용됩니다. 예를 들어, Redis와 같은 인메모리 데이터 저장소를 활용하여 분산 잠금을 구현할 수 있습니다. 

## ✅6. 데드락(Deadlock)과 잠금

잠금 메커니즘을 사용할 때 데드락이 발생할 수 있습니다. 데드락은 두 개 이상의 트랜잭션이 서로가 소유한 잠금을 기다리며 무한 대기 상태에 빠지는 현상입니다. 이를 방지하기 위해 데이터베이스 시스템은 데드락 감지 및 해소 알고리즘을 사용하며, 개발자는 트랜잭션의 잠금 순서를 일관되게 유지하고, 트랜잭션의 범위를 최소화하여 데드락 발생 가능성을 줄일 수 있습니다.

잠금 메커니즘은 데이터베이스 시스템의 동시성 제어와 데이터 무결성 유지에 핵심적인 역할을 합니다. 개발자는 이러한 메커니즘을 이해하고 적절하게 활용하여 효율적이고 안전한 데이터베이스 시스템을 구축할 수 있습니다.
