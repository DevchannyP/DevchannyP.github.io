---
layout: post
title: "CHAP 13. 입출력 스트림"
date: 2025-05-17
categories: [backend, language, java]
tags: [backend, language, java]
thumbnail: /assets/img/post-thumbnails/intro12.png
author: Devchanny
---


# ** 📌1단계: 입출력 스트림이란? **

- *스트림(Stream)은 데이터가 지나가는 길(통로)**이라고 생각하면 돼요.
- **입력 스트림(Input Stream):** 데이터를 "읽어오는" 길→ 예: **책을 읽는 것, 파일에서 데이터를 읽는 것**
- **출력 스트림(Output Stream):** 데이터를 "보내는" 길→ 예: **글을 쓰는 것, 화면에 출력하는 것**

💡 **빨대로 주스를 마시는 걸 떠올려 보세요.**

주스(데이터)가 **컵(파일)**에서 **입(프로그램)**으로 들어오는 것이 **입력 스트림**이고,

주스를 **다른 컵(파일)**으로 붓는 것이 **출력 스트림**이에요!

---

# **2단계: 스트림의 종류 (바이트 스트림 vs. 문자 스트림)**

📌 **바이트 스트림 (Byte Stream)**

- **1바이트(8비트) 단위**로 데이터를 처리해요.
- **이미지, 동영상, 바이너리 파일**을 다룰 때 사용해요.
- **대표 클래스:** `InputStream`, `OutputStream`

📌 **문자 스트림 (Character Stream)**

- **2바이트(16비트) 단위**로 데이터를 처리해요.
- **문자(텍스트) 데이터를 다룰 때 적합**해요.
- **대표 클래스:** `Reader`, `Writer`

💡 **비유:**

바이트 스트림은 **알파벳 한 글자씩 읽는 것**,

문자 스트림은 **문장 단위로 읽는 것**이에요!

---

# **3단계: 스트림 클래스 구조와 상속 관계**

자바의 입출력 스트림은 **부모-자식 관계(상속)**로 구성되어 있어요.

📌 **바이트 스트림 구조**

- `InputStream` (최상위 클래스)
    - `FileInputStream` (파일 읽기)
    - `BufferedInputStream` (빠르게 읽기)
- `OutputStream` (최상위 클래스)
    - `FileOutputStream` (파일 쓰기)
    - `BufferedOutputStream` (빠르게 쓰기)

📌 **문자 스트림 구조**

- `Reader` (최상위 클래스)
    - `FileReader` (파일에서 문자 읽기)
    - `BufferedReader` (한 줄씩 빠르게 읽기)
- `Writer` (최상위 클래스)
    - `FileWriter` (파일에 문자 쓰기)
    - `BufferedWriter` (한 줄씩 빠르게 쓰기)

💡 **비유:**

이건 마치, "엄마(부모 클래스)와 아들(자식 클래스)" 같은 관계예요.

엄마가 기본적인 요리를 가르쳐주고, 아들은 그걸 응용해서 더 맛있게 만들 수 있죠!

---

# **4단계: 스트림 체이닝 (Chaining)과 데코레이터 패턴**

스트림을 여러 개 연결해서 사용하면 **더 강력한 기능**을 만들 수 있어요.

이걸 **스트림 체이닝 (Chaining)**이라고 해요.

📌 **예제: 파일을 읽을 때 버퍼를 추가하면 속도가 빨라짐**

```java
FileInputStream fis = new FileInputStream("data.txt");
BufferedInputStream bis = new BufferedInputStream(fis);
```

- `FileInputStream` → 파일에서 데이터를 "직접" 읽음
- `BufferedInputStream` → **버퍼를 사용해** 더 빠르게 읽음

💡 **비유:**

음식을 먹을 때 "숟가락"을 사용하면 더 편하죠?

스트림 체이닝은 **그릇 → 숟가락 → 입**처럼 **도구를 추가해 더 효율적으로 먹는 것**과 같아요.

---

# **5단계: 표준 입출력 (System.in, System.out, System.err)**

**자바에서 기본적으로 제공하는 입력/출력 스트림**

📌 **System.in** → 키보드 입력 (`InputStream`)

```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String name = br.readLine();
```

📌 **System.out** → 화면 출력 (`PrintStream`)

```java
System.out.println("Hello, World!");
```

📌 **System.err** → 에러 메시지 출력

```java
System.err.println("오류 발생!");
```

💡 **비유:**

- **System.in** → "사람이 귀로 듣는 것"
- **System.out** → "사람이 입으로 말하는 것"
- **System.err** → "사람이 놀라서 소리치는 것"

---

# **6단계: 객체 직렬화 (Serialization)**

📌 **직렬화란?**

"자바 객체를 **파일에 저장하거나 네트워크로 보내는 것**"

📌 **역직렬화란?**

"저장된 데이터를 **다시 자바 객체로 변환하는 것**"

📌 **직렬화 예제**

```java
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("data.ser"));
oos.writeObject(new Person("홍길동", 25));
oos.close();
```

📌 **역직렬화 예제**

```java
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("data.ser"));
Person person = (Person) ois.readObject();
ois.close();
```

💡 **비유:**

- 직렬화 → "로봇을 부품으로 분해해서 박스에 넣기"
- 역직렬화 → "박스에서 부품을 꺼내 다시 조립하기"

---

# **7단계: 고성능 입출력 (NIO & NIO.2)**

📌 **NIO(New I/O)란?**

기존 I/O보다 **더 빠른 입출력 방식**을 제공하는 자바 API

📌 **NIO의 핵심 개념**

- **버퍼 (Buffer)** → 데이터를 저장하는 공간
- **채널 (Channel)** → 데이터를 읽고 쓰는 통로
- **셀렉터 (Selector)** → 여러 개의 채널을 관리

📌 **NIO 예제: 파일 복사**

```java
FileChannel inChannel = FileChannel.open(Paths.get("source.txt"), StandardOpenOption.READ);
FileChannel outChannel = FileChannel.open(Paths.get("destination.txt"), StandardOpenOption.WRITE, StandardOpenOption.CREATE);
ByteBuffer buffer = ByteBuffer.allocate(1024);
while (inChannel.read(buffer) > 0) {
    buffer.flip();
    outChannel.write(buffer);
    buffer.clear();
}
```

💡 **비유:**

기존 I/O는 **한 줄씩 종이를 넘겨 읽는 것**,

NIO는 **한 페이지를 통째로 넘겨 빠르게 읽는 것**이에요.

---

# **📌 정리**

✅ **스트림(Stream)** → 데이터를 읽고 쓰는 통로

✅ **바이트 스트림 vs 문자 스트림** → 바이트(1Byte) vs 문자(2Byte)

✅ **스트림 체이닝** → 여러 스트림을 연결해 성능 향상

✅ **표준 입출력** → System.in, System.out, System.err

✅ **직렬화** → 객체를 저장하고 복원하는 기능

✅ **NIO** → 고성능 입출력 방식

---

# **📌 8단계: 고급 입출력 최적화 기법**

자바 입출력 스트림을 더 빠르게 실행하려면 **최적화 기법**을 적용해야 해요.

### **1. 버퍼(Buffer) 활용**

**버퍼링(Buffering)이란?**

- 데이터를 **한꺼번에 모아서 입출력하는 기법**
- 매번 1바이트씩 읽기보다 **한 번에 1024바이트(1KB)씩 읽으면 속도 향상**
- **BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter** 사용

📌 **예제: 버퍼를 사용한 파일 복사 (더 빠름!)**

```java
BufferedInputStream bis = new BufferedInputStream(new FileInputStream("source.txt"));
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("destination.txt"));

byte[] buffer = new byte[1024]; // 1KB 버퍼
int bytesRead;
while ((bytesRead = bis.read(buffer)) != -1) {
    bos.write(buffer, 0, bytesRead);
}
bis.close();
bos.close();

```

✅ **버퍼를 사용하면 파일 입출력 속도가 2~3배 빨라져요!**

---

### **2. try-with-resources (자동 자원 해제)**

- 기존의 try-catch 방식에서는 **finally 블록에서 close()를 호출**해야 했어요.
- **try-with-resources** 문법을 사용하면 **자동으로 스트림을 닫아줘요!**
- **자바 7(Java 7) 이상에서 사용 가능**

📌 **예제: try-with-resources로 자동 자원 해제**

```java
try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

✅ **try 블록이 끝나면 자동으로 `br.close()` 실행됨!**

---

### **3. Direct Buffer 활용 (NIO)**

- 일반 `ByteBuffer`는 **Heap Memory(자바 힙 메모리)**를 사용해요.
- `DirectByteBuffer`는 **OS의 네이티브 메모리**를 사용해서 **더 빠름!**
- 대용량 데이터 처리가 필요할 때 유용!

📌 **예제: Direct Buffer 사용**

```java
ByteBuffer buffer = ByteBuffer.allocateDirect(1024); // Direct Buffer 생성
```

✅ **메모리 복사가 적어 속도가 훨씬 빨라져요!**

---

# **📌 9단계: 보안(Security) & 암호화(Encryption)**

네트워크에서 데이터를 전송하거나, 중요한 파일을 저장할 때는 **보안이 중요해요!**

자바에서는 **암호화와 복호화** 기능을 제공해요.

### **1. 데이터 암호화하기 (AES)**

- *AES (Advanced Encryption Standard)**는 **강력한 암호화 알고리즘**
- `javax.crypto` 패키지를 활용

📌 **예제: AES로 파일 암호화**

```java
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.util.Base64;

public class AESEncryption {
    public static void main(String[] args) throws Exception {
        // 암호화 키 생성
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(128);
        SecretKey secretKey = keyGen.generateKey();

        // 암호화
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        byte[] encrypted = cipher.doFinal("비밀 메시지".getBytes());
        System.out.println("암호화된 데이터: " + Base64.getEncoder().encodeToString(encrypted));
    }
}
```

✅ **AES를 활용하면 중요한 데이터를 보호할 수 있어요!**

---

# **📌 10단계: 네트워크 입출력 (Socket I/O)**

자바에서는 네트워크 통신을 위해 **소켓(Socket)**을 사용할 수 있어요.

### **1. 서버 만들기 (Socket Server)**

- `ServerSocket`을 사용해 클라이언트의 요청을 받을 수 있어요.
- **네트워크를 통해 데이터를 주고받는 입출력 스트림**을 활용!

📌 **예제: 서버 만들기**

```java
import java.io.*;
import java.net.*;

public class ServerExample {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(5000);
        System.out.println("서버가 실행 중...");

        Socket clientSocket = serverSocket.accept(); // 클라이언트 연결 대기
        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);

        String input = in.readLine();
        System.out.println("클라이언트: " + input);
        out.println("서버 응답: " + input.toUpperCase());

        clientSocket.close();
        serverSocket.close();
    }
}
```

✅ **네트워크로 데이터를 주고받을 수 있어요!**

---

# **📌 11단계: 파일 시스템 조작 (NIO.2 활용)**

자바 NIO.2 (`java.nio.file`)를 활용하면 **더 강력한 파일 조작 기능**을 사용할 수 있어요.

### **1. 파일 복사 & 이동**

📌 **예제: 파일 복사하기**

```java
import java.nio.file.*;

public class FileCopyExample {
    public static void main(String[] args) throws Exception {
        Path source = Paths.get("source.txt");
        Path destination = Paths.get("destination.txt");

        Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);
        System.out.println("파일 복사 완료!");
    }
}
```

✅ **`Files.copy()`를 사용하면 쉽게 파일을 복사할 수 있어요!**

---

# **📌 12단계: 실전 프로젝트 활용**

이제까지 배운 내용을 **실전에서 어떻게 활용할 수 있는지** 알아볼게요.

### **1. 로그 시스템 구현**

- `FileWriter`와 `BufferedWriter`를 활용해 **로그 시스템을 구현**할 수 있어요.
- 서버가 동작하는 동안 **로그를 남기는 기능**을 만들 수 있어요.

📌 **예제: 로그 시스템**

```java
import java.io.*;
import java.time.LocalDateTime;

public class Logger {
    public static void log(String message) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("log.txt", true))) {
            writer.write(LocalDateTime.now() + " - " + message);
            writer.newLine();
        }
    }

    public static void main(String[] args) throws IOException {
        log("서버 시작됨.");
        log("사용자가 로그인함.");
    }
}
```

✅ **서버의 동작을 기록할 수 있어요!**

---

# **📌 정리: 자바 입출력 스트림 완전 정복**

| 단계 | 주제 |
| --- | --- |
| 1~7 | 기본 개념, 스트림의 종류, 표준 입출력 |
| 8 | 입출력 최적화 (버퍼, Direct Buffer) |
| 9 | 보안 (AES 암호화) |
| 10 | 네트워크 입출력 (소켓) |
| 11 | 파일 시스템 조작 (NIO.2) |
| 12 | 실전 프로젝트 활용 (로그 시스템) |

---

# **📌 13단계: 대용량 데이터 처리 (Chunk I/O)**

### **1. 대용량 파일을 한 번에 읽으면 문제가 생김!**

- **1GB 이상의 파일**을 한 번에 `read()` 하면 **메모리가 부족**해요. 😱
- 해결 방법? **작은 단위(Chunk, 조각)로 나눠서 읽기!**

📌 **예제: 1MB 단위로 파일 복사하기**

```java
import java.io.*;

public class LargeFileCopy {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream("large_file.mp4");
        FileOutputStream fos = new FileOutputStream("copy.mp4");

        byte[] buffer = new byte[1024 * 1024]; // 1MB 버퍼
        int bytesRead;

        while ((bytesRead = fis.read(buffer)) != -1) {
            fos.write(buffer, 0, bytesRead);
        }

        fis.close();
        fos.close();
        System.out.println("파일 복사 완료!");
    }
}
```

✅ **파일을 조각(Chunk) 단위로 나누면 메모리 효율이 좋아져요!**

# **📌 14단계: 멀티스레드 입출력 (병렬 I/O)**

대용량 파일을 읽을 때 **멀티스레드**를 활용하면 더 빠르게 처리할 수 있어요!

👉 **멀티스레드 I/O = CPU 여러 개 사용 = 속도 향상!**

📌 **예제: 멀티스레드로 파일 복사**

```java
import java.io.*;

class FileCopyThread extends Thread {
    private String source;
    private String destination;

    public FileCopyThread(String source, String destination) {
        this.source = source;
        this.destination = destination;
    }

    @Override
    public void run() {
        try (FileInputStream fis = new FileInputStream(source);
             FileOutputStream fos = new FileOutputStream(destination)) {

            byte[] buffer = new byte[1024 * 1024]; // 1MB 버퍼
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, bytesRead);
            }
            System.out.println(source + " -> " + destination + " 복사 완료!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

public class MultiThreadFileCopy {
    public static void main(String[] args) {
        String[] files = {"file1.mp4", "file2.mp4", "file3.mp4"};

        for (String file : files) {
            new FileCopyThread(file, "copy_" + file).start();
        }
    }
}
```

✅ **파일 3개를 동시에 복사! (멀티스레드로 속도 UP! 🚀)**

---

# **📌 15단계: 파일 감시 시스템 (WatchService)**

### **1. 실시간으로 폴더 변화를 감지하는 기능**

- 새로운 파일이 추가되었는지?
- 파일이 삭제되었는지?
- 파일이 수정되었는지?

📌 **예제: 특정 폴더를 감시하고 변화 감지**

```java
import java.nio.file.*;

public class DirectoryWatcher {
    public static void main(String[] args) throws Exception {
        WatchService watchService = FileSystems.getDefault().newWatchService();
        Path path = Paths.get("C:/myfolder");
        path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
                                      StandardWatchEventKinds.ENTRY_DELETE,
                                      StandardWatchEventKinds.ENTRY_MODIFY);

        System.out.println("폴더 감시 시작...");
        while (true) {
            WatchKey key = watchService.take();
            for (WatchEvent<?> event : key.pollEvents()) {
                System.out.println("이벤트 발생: " + event.kind() + " -> " + event.context());
            }
            key.reset();
        }
    }
}
```

✅ **파일이 추가/삭제/수정될 때 자동으로 감지 가능!**

---

# **📌 16단계: 메모리 매핑 파일 (Memory Mapped File)**

### **1. 초고속 파일 입출력을 원한다면?**

- 기존 `FileInputStream` 방식보다 **최대 10배 빠른 입출력 가능!** 🚀
- `MappedByteBuffer`를 사용해 **파일을 메모리에 매핑**하면 속도가 빨라짐.

📌 **예제: 초고속 파일 읽기**

```java
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

public class MemoryMappedFileExample {
    public static void main(String[] args) throws Exception {
        RandomAccessFile file = new RandomAccessFile("bigfile.txt", "r");
        FileChannel channel = file.getChannel();

        MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size());

        for (int i = 0; i < buffer.limit(); i++) {
            System.out.print((char) buffer.get()); // 파일 내용 출력
        }

        file.close();
    }
}
```

✅ **파일이 직접 메모리에 매핑되어 속도가 훨씬 빨라요!**

---

# **📌 17단계: 압축 & 해제 (ZIP 파일)**

### **1. 파일을 압축해서 저장 공간 절약하기**

자바의 `java.util.zip` 패키지를 활용하면 **ZIP 파일을 만들고 해제할 수 있어요.** 🎯

📌 **예제: ZIP 파일 만들기**

```java
import java.io.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipExample {
    public static void main(String[] args) throws IOException {
        FileOutputStream fos = new FileOutputStream("output.zip");
        ZipOutputStream zipOut = new ZipOutputStream(fos);

        File fileToZip = new File("largefile.txt");
        FileInputStream fis = new FileInputStream(fileToZip);

        ZipEntry zipEntry = new ZipEntry(fileToZip.getName());
        zipOut.putNextEntry(zipEntry);

        byte[] buffer = new byte[1024];
        int bytesRead;
        while ((bytesRead = fis.read(buffer)) != -1) {
            zipOut.write(buffer, 0, bytesRead);
        }

        fis.close();
        zipOut.closeEntry();
        zipOut.close();

        System.out.println("ZIP 파일 생성 완료!");
    }
}
```

✅ **대용량 파일을 ZIP으로 압축하면 공간을 절약할 수 있어요!**

---

# **📌 최종 정리**

| 단계 | 내용 |
| --- | --- |
| 13 | 대용량 데이터 처리 (Chunk I/O) |
| 14 | 멀티스레드 입출력 (병렬 처리) |
| 15 | 파일 감시 시스템 (WatchService) |
| 16 | 초고속 파일 입출력 (Memory Mapped File) |
| 17 | 파일 압축 & 해제 (ZIP) |

---

# **📌 18단계: 고급 파일 암호화 (AES-GCM)**

### **1. 보안이 중요한 데이터를 보호하려면?**

- 기존 **AES 암호화**보다 **더 강력한 AES-GCM** 방식 사용!
- 해커가 데이터를 변조하는 걸 막을 수 있음.

📌 **예제: AES-GCM을 사용한 파일 암호화**

```java
import javax.crypto.*;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.security.SecureRandom;
import java.util.Base64;

public class AESGCMFileEncryption {
    public static void main(String[] args) throws Exception {
        String key = "0123456789abcdef"; // 16바이트 키 (128비트)
        SecretKey secretKey = new SecretKeySpec(key.getBytes(), "AES");

        // 암호화
        byte[] iv = new byte[12]; // 12바이트 IV (초기 벡터)
        new SecureRandom().nextBytes(iv);
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, new GCMParameterSpec(128, iv));

        byte[] plainText = "비밀 데이터".getBytes();
        byte[] cipherText = cipher.doFinal(plainText);

        // 파일에 저장
        try (FileOutputStream fos = new FileOutputStream("encrypted.dat")) {
            fos.write(iv); // IV 저장
            fos.write(cipherText);
        }
        System.out.println("파일 암호화 완료!");
    }
}
```

✅ **AES-GCM을 활용하면 더 강력한 보안이 가능해요!**

---

# **📌 19단계: 데이터 직렬화 최적화 (Externalizable)**

### **1. 기본 직렬화는 속도가 느리다?**

- 기본 `Serializable` 방식은 **모든 필드를 자동 저장**해서 비효율적임.
- **`Externalizable`을 사용하면 원하는 필드만 저장**할 수 있어서 더 빠름!

📌 **예제: Externalizable을 사용한 직렬화**

```java
import java.io.*;

class User implements Externalizable {
    private String name;
    private int age;

    // 기본 생성자 필수!
    public User() {}

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 직접 직렬화할 필드 지정
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(name); // 문자열만 저장
    }

    // 직접 역직렬화할 필드 지정
    @Override
    public void readExternal(ObjectInput in) throws IOException {
        name = in.readUTF();
    }

    @Override
    public String toString() {
        return "이름: " + name + ", 나이: (저장 안 함)";
    }
}

public class ExternalizableExample {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        // 객체 직렬화
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("user.ser"));
        oos.writeObject(new User("홍길동", 30));
        oos.close();

        // 객체 역직렬화
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("user.ser"));
        User user = (User) ois.readObject();
        ois.close();

        System.out.println("복원된 객체: " + user);
    }
}
```

✅ **필요한 데이터만 직렬화하면 속도가 더 빠름!**

---

# **📌 20단계: 파일을 데이터베이스처럼 사용하기 (RandomAccessFile)**

### **1. 파일에서 특정 위치의 데이터만 수정할 수 있을까?**

- 기존 `FileReader`, `FileWriter`는 **처음부터 끝까지 읽어야 함**.
- **`RandomAccessFile`을 사용하면 원하는 위치의 데이터를 수정할 수 있음!**

📌 **예제: 파일 특정 위치의 데이터 수정**

```java
import java.io.RandomAccessFile;

public class RandomAccessFileExample {
    public static void main(String[] args) throws Exception {
        RandomAccessFile raf = new RandomAccessFile("data.txt", "rw");

        // 처음 10바이트 읽기
        byte[] buffer = new byte[10];
        raf.read(buffer);
        System.out.println("처음 10바이트: " + new String(buffer));

        // 파일의 5번째 위치부터 "HELLO" 삽입
        raf.seek(5);
        raf.write("HELLO".getBytes());

        raf.close();
        System.out.println("파일 수정 완료!");
    }
}
```

✅ **데이터베이스처럼 파일을 빠르게 수정 가능!**

---

# **📌 21단계: 로그 시스템 최적화 (Rolling Logs)**

### **1. 로그 파일이 너무 커지면 자동으로 새 로그 파일 만들기**

- **로그 파일이 10MB가 넘으면 새로운 로그 파일을 생성**
- 로그 데이터를 오래 보관하면서 저장 공간도 절약 가능!

📌 **예제: 자동 로그 롤링 시스템**

```java
import java.io.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class RollingLog {
    private static final long MAX_SIZE = 10 * 1024 * 1024; // 10MB

    public static void log(String message) throws IOException {
        File logFile = new File("log.txt");

        // 파일 크기 체크
        if (logFile.length() > MAX_SIZE) {
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            File newFile = new File("log_" + timestamp + ".txt");
            logFile.renameTo(newFile);
        }

        // 로그 쓰기
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(logFile, true))) {
            writer.write(LocalDateTime.now() + " - " + message);
            writer.newLine();
        }
    }

    public static void main(String[] args) throws IOException {
        log("서버 시작됨.");
        log("사용자가 로그인함.");
    }
}
```

✅ **로그 파일이 커지면 자동으로 새로운 파일을 생성!**

---

# **📌 22단계: 스트림을 활용한 실시간 데이터 처리 (Pipeline)**

### **1. 데이터를 여러 단계로 가공할 수 있을까?**

- **파일 → 압축 → 암호화 → 네트워크 전송** 같은 데이터 파이프라인 구축 가능!

📌 **예제: 데이터를 읽고, 압축하고, 네트워크로 전송하는 스트림 체이닝**

```java
import java.io.*;
import java.net.Socket;
import java.util.zip.GZIPOutputStream;

public class StreamPipelineExample {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream("data.txt");
        GZIPOutputStream gzipOut = new GZIPOutputStream(new FileOutputStream("data.gz"));
        BufferedOutputStream netOut = new BufferedOutputStream(new Socket("localhost", 5000).getOutputStream());

        byte[] buffer = new byte[1024];
        int bytesRead;
        while ((bytesRead = fis.read(buffer)) != -1) {
            gzipOut.write(buffer, 0, bytesRead); // 압축
            netOut.write(buffer, 0, bytesRead);  // 네트워크 전송
        }

        fis.close();
        gzipOut.close();
        netOut.close();
        System.out.println("데이터 처리 완료!");
    }
}
```

✅ **파일을 읽고, 압축하고, 네트워크로 보내는 파이프라인 구축 가능!**

# **📌 최종 정리: 입출력 스트림 끝판왕**

| 단계 | 내용 |
| --- | --- |
| 18 | 고급 파일 암호화 (AES-GCM) |
| 19 | 데이터 직렬화 최적화 (Externalizable) |
| 20 | 파일을 DB처럼 사용 (RandomAccessFile) |
| 21 | 로그 시스템 최적화 (Rolling Logs) |
| 22 | 스트림 활용 실시간 데이터 처리 (Pipeline) |

---

# **📌 23단계: 실시간 파일 시스템 모니터링 (WatchService 고급 활용)**

### **1. 실시간으로 특정 폴더의 변경 사항을 감지하는 기능**

- **파일이 추가/삭제/수정되는지 실시간으로 감지**
- **이벤트 기반 처리**로 **CPU 사용량을 줄이고 반응 속도를 높일 수 있음**

📌 **예제: 특정 폴더를 감시하고 변경 사항을 감지하는 코드**

```java
import java.nio.file.*;

public class AdvancedDirectoryWatcher {
    public static void main(String[] args) throws Exception {
        WatchService watchService = FileSystems.getDefault().newWatchService();
        Path path = Paths.get("C:/myfolder");
        path.register(watchService,
                      StandardWatchEventKinds.ENTRY_CREATE,
                      StandardWatchEventKinds.ENTRY_DELETE,
                      StandardWatchEventKinds.ENTRY_MODIFY);

        System.out.println("파일 변경 감지 시작...");

        while (true) {
            WatchKey key = watchService.take();
            for (WatchEvent<?> event : key.pollEvents()) {
                System.out.println("이벤트 발생: " + event.kind() + " -> " + event.context());
            }
            key.reset();
        }
    }
}
```

✅ **파일이 생성/수정/삭제될 때 자동으로 감지하여 이벤트 로그 출력!**

---

# **📌 24단계: 클라우드 파일 입출력 (AWS S3, Google Drive 연동)**

### **1. 클라우드 스토리지에 파일 업로드/다운로드**

- 로컬 파일을 **AWS S3, Google Drive 등에 업로드**
- **Apache Commons FileUpload** 또는 **AWS SDK**를 활용

📌 **예제: AWS S3에 파일 업로드 (Java AWS SDK 활용)**

```java
import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.PutObjectRequest;
import software.amazon.awssdk.regions.Region;
import java.nio.file.Paths;

public class S3FileUpload {
    public static void main(String[] args) {
        S3Client s3 = S3Client.builder().region(Region.AP_NORTHEAST_2).build();
        String bucketName = "my-bucket";
        String fileName = "upload.txt";

        PutObjectRequest request = PutObjectRequest.builder()
                .bucket(bucketName)
                .key(fileName)
                .build();

        s3.putObject(request, Paths.get(fileName));
        System.out.println("파일 업로드 완료!");
    }
}
```

✅ **클라우드 파일 스토리지에 자동으로 업로드 가능!**

---

# **📌 25단계: 비동기 입출력 (Asynchronous I/O, AIO)**

### **1. 기존 I/O는 느리다!**

- 기존 `InputStream`은 **순차적(Blocking)으로 처리**
- *비동기 입출력(AIO)**를 활용하면 **CPU가 놀지 않고 다른 작업을 할 수 있음!**

📌 **예제: 비동기 파일 읽기 (NIO.2 활용)**

```java
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.concurrent.Future;

public class AsyncFileRead {
    public static void main(String[] args) throws Exception {
        Path path = Path.of("largefile.txt");
        AsynchronousFileChannel channel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);

        ByteBuffer buffer = ByteBuffer.allocate(1024);
        Future<Integer> result = channel.read(buffer, 0);

        while (!result.isDone()) {
            System.out.println("다른 작업 수행 중...");
            Thread.sleep(500); // CPU를 놀리지 않도록 다른 작업 수행
        }

        buffer.flip();
        System.out.println("파일 읽기 완료: " + new String(buffer.array()).trim());
        channel.close();
    }
}
```

✅ **비동기 입출력을 사용하면 CPU를 효율적으로 활용 가능!**

---

# **📌 26단계: 네트워크 스트림 최적화 (Socket + Buffer)**

### **1. 네트워크에서 데이터를 전송할 때 성능 최적화 방법**

- 기본 `Socket` 스트림은 **속도가 느릴 수 있음**
- **Buffered Streams + NIO 채널**을 사용하면 **속도 UP!** 🚀

📌 **예제: 네트워크에서 버퍼를 활용한 파일 전송**

```java
import java.io.*;
import java.net.*;

public class BufferedSocketServer {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(5000);
        System.out.println("서버 대기 중...");

        Socket socket = serverSocket.accept();
        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("received.txt"));

        byte[] buffer = new byte[1024];
        int bytesRead;
        while ((bytesRead = bis.read(buffer)) != -1) {
            bos.write(buffer, 0, bytesRead);
        }

        bis.close();
        bos.close();
        socket.close();
        serverSocket.close();
        System.out.println("파일 전송 완료!");
    }
}
```

✅ **버퍼를 활용하면 네트워크 전송 속도가 훨씬 빨라져요!**

---

# **📌 27단계: 데이터 압축 & 해제 최적화 (GZIP, BZIP2)**

### **1. 네트워크 트래픽을 줄이려면?**

- 데이터를 압축해서 전송하면 **트래픽 비용 절감**
- GZIP & BZIP2 같은 **고성능 압축 알고리즘** 활용

📌 **예제: GZIP을 사용한 파일 압축**

```java
import java.io.*;
import java.util.zip.GZIPOutputStream;

public class GzipCompression {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream("largefile.txt");
        GZIPOutputStream gzipOut = new GZIPOutputStream(new FileOutputStream("compressed.gz"));

        byte[] buffer = new byte[1024];
        int bytesRead;
        while ((bytesRead = fis.read(buffer)) != -1) {
            gzipOut.write(buffer, 0, bytesRead);
        }

        fis.close();
        gzipOut.close();
        System.out.println("파일 압축 완료!");
    }
}
```

✅ **GZIP을 활용하면 네트워크 전송 속도가 최대 50% 빨라짐!**

---

# **📌 최종 정리: 자바 입출력 스트림 완전 마스터**

| 단계 | 내용 |
| --- | --- |
| 23 | 실시간 파일 시스템 모니터링 (WatchService) |
| 24 | 클라우드 파일 입출력 (AWS S3, Google Drive) |
| 25 | 비동기 입출력 (AIO) |
| 26 | 네트워크 스트림 최적화 (Socket + Buffer) |
| 27 | 데이터 압축 & 해제 최적화 (GZIP, BZIP2) |

---

# **📌 28단계: 초고속 입출력 기술 (Zero-Copy, Direct I/O)**

### **1. 기존 I/O는 메모리 복사가 많아 속도가 느림**

- 기존 방식: **파일 → 커널 버퍼 → 사용자 버퍼 → 네트워크**
- **Zero-Copy 기술**을 사용하면 → **파일 → 네트워크** 바로 전송 가능! 🚀

📌 **예제: Zero-Copy를 사용한 초고속 파일 전송 (sendfile)**

```java
import java.io.*;
import java.nio.channels.FileChannel;
import java.nio.channels.SocketChannel;
import java.net.InetSocketAddress;

public class ZeroCopyFileTransfer {
    public static void main(String[] args) throws IOException {
        File file = new File("largefile.mp4");
        FileChannel fileChannel = new FileInputStream(file).getChannel();
        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("localhost", 5000));

        fileChannel.transferTo(0, fileChannel.size(), socketChannel);
        fileChannel.close();
        socketChannel.close();
        System.out.println("파일 전송 완료! (Zero-Copy)");
    }
}
```

✅ **CPU 사용량을 줄이고 초고속으로 파일을 전송할 수 있어요!**

---

# **📌 29단계: AI 기반 데이터 처리 (머신러닝과 자바 I/O)**

### **1. 대용량 데이터에서 인공지능(AI) 모델이 학습하는 방법?**

- 대량의 로그, 텍스트 데이터를 빠르게 분석해야 함
- **자바 스트림(Stream API) + Apache Spark**로 AI 모델 학습 가능

📌 **예제: AI 학습을 위한 로그 데이터 스트리밍 (Apache Spark 활용)**

```java
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.SparkConf;

public class LogProcessingWithAI {
    public static void main(String[] args) {
        SparkConf conf = new SparkConf().setAppName("LogProcessing").setMaster("local");
        JavaSparkContext sc = new JavaSparkContext(conf);

        JavaRDD<String> logs = sc.textFile("server_logs.txt");
        long errorCount = logs.filter(line -> line.contains("ERROR")).count();

        System.out.println("총 에러 발생 횟수: " + errorCount);
        sc.close();
    }
}
```

✅ **실시간으로 로그 데이터를 분석하고 AI 학습 모델에 활용 가능!**

---

# **📌 30단계: 블록체인 기반 파일 저장 (IPFS + 자바)**

### **1. 기존 파일 저장 방식은 해킹에 취약하다!**

- 파일을 중앙 서버가 관리하면 보안 문제가 발생할 수 있음
- **IPFS(InterPlanetary File System) + Java**를 활용하면 **탈중앙 파일 저장 가능!**

📌 **예제: IPFS에 파일 업로드하기**

```java
import io.ipfs.api.IPFS;
import io.ipfs.api.MerkleNode;
import io.ipfs.api.NamedStreamable;

public class IPFSFileUpload {
    public static void main(String[] args) throws Exception {
        IPFS ipfs = new IPFS("/ip4/127.0.0.1/tcp/5001");
        NamedStreamable.FileWrapper file = new NamedStreamable.FileWrapper(new File("data.txt"));

        MerkleNode addResult = ipfs.add(file).get(0);
        System.out.println("IPFS 해시: " + addResult.hash.toBase58());
    }
}
```

✅ **IPFS를 사용하면 해킹이 불가능한 파일 저장 시스템 구축 가능!**

---

# **📌 31단계: 미래의 자바 I/O (Project Loom & Virtual Threads)**

### **1. 기존 스레드는 너무 무겁다!**

- 기존 `Thread`는 **운영체제(OS)에서 관리**하므로 생성 비용이 큼
- 자바 21부터 등장한 **"Virtual Threads"**를 사용하면 가벼운 스레드 생성 가능!

📌 **예제: Virtual Threads로 100만 개의 파일을 동시에 읽기**

```java
import java.nio.file.*;
import java.util.concurrent.*;

public class VirtualThreadExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();

        for (int i = 0; i < 1_000_000; i++) {
            int fileNumber = i;
            executor.submit(() -> {
                try {
                    String content = Files.readString(Path.of("file" + fileNumber + ".txt"));
                    System.out.println("파일 읽음: " + fileNumber);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
        }

        executor.shutdown();
    }
}
```

✅ **가벼운 Virtual Thread 덕분에 100만 개 파일을 동시에 읽을 수 있음!**

---

# **📌 최종 정리: 자바 입출력의 현재와 미래**

| 단계 | 내용 |
| --- | --- |
| 28 | 초고속 I/O (Zero-Copy, Direct I/O) |
| 29 | AI 기반 데이터 처리 (머신러닝 + Java I/O) |
| 30 | 블록체인 파일 저장 (IPFS) |
| 31 | 미래의 자바 I/O (Project Loom & Virtual Threads) |

---

# **📌 32단계: 클라우드 네이티브 I/O (Kubernetes + Java)**

### **1. 미래의 애플리케이션은 클라우드에서 실행됨**

- **AWS, GCP, Azure**와 같은 클라우드 환경에서 자바 I/O를 최적화해야 함
- *쿠버네티스(Kubernetes)**에서 파일 I/O와 네트워크 I/O를 어떻게 활용할까?

📌 **예제: 쿠버네티스 기반 로그 저장 시스템**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: java-log-pod
spec:
  containers:
    - name: java-log-container
      image: openjdk:latest
      volumeMounts:
        - mountPath: "/var/logs"
          name: log-volume
  volumes:
    - name: log-volume
      emptyDir: {}
```

✅ **컨테이너에서 실행되는 자바 애플리케이션이 로그 파일을 클라우드에서 저장!**

---

# **📌 33단계: 양자 컴퓨팅 기반 데이터 전송 (Quantum I/O)**

### **1. 기존의 네트워크는 보안이 취약하다!**

- **양자 컴퓨팅**이 발전하면서 **양자 키 분배(QKD)**를 통한 **초보안 데이터 전송**이 가능해짐!
- **자바에서 양자 기반 통신을 어떻게 활용할까?**

📌 **예제: IBM Qiskit을 활용한 양자 데이터 전송**

```python
from qiskit import QuantumCircuit, execute, Aer

qc = QuantumCircuit(1, 1)
qc.h(0)
qc.measure(0, 0)

simulator = Aer.get_backend('qasm_simulator')
result = execute(qc, simulator, shots=1).result()
print(result.get_counts())
```

✅ **양자 컴퓨터를 활용해 해킹이 불가능한 데이터 전송 가능!**

---

# **📌 34단계: 인간-컴퓨터 인터페이스(HCI)와 I/O 결합**

### **1. 인간과 컴퓨터가 데이터를 주고받는 방식이 진화하고 있음**

- 기존 I/O: **키보드, 마우스, 터치스크린**
- 미래 I/O: **뇌-컴퓨터 인터페이스(BCI), 증강현실(AR), 홀로그램 인터페이스**

📌 **예제: 뇌파 데이터를 활용한 자바 I/O 시스템**

```java
import com.neurosky.thinkgear.*;

public class BrainComputerInterface {
    public static void main(String[] args) {
        TGDevice device = new TGDevice(new TGStreamReader());
        device.connect();

        device.addListener(new TGDeviceListener() {
            @Override
            public void onMeditationLevel(int level) {
                System.out.println("집중도: " + level);
            }
        });
    }
}
```

✅ **인간의 뇌파를 분석해 자바 애플리케이션과 연결 가능!**

---

# **📌 35단계: 자바 I/O의 궁극적인 미래 – 인간과 AI의 결합**

### **1. 미래에는 인간과 AI가 데이터를 실시간으로 주고받는 환경이 만들어질 것!**

- **AI가 실시간으로 인간의 감정을 분석하여 데이터 전송**
- **클라우드, 양자 네트워크, 증강 현실, 생체 인식과 결합된 자바 I/O**

📌 **예제: 감정을 분석해 파일 입출력 결정하기**

```java
import org.tensorflow.*;

public class EmotionBasedIO {
    public static void main(String[] args) {
        try (SavedModelBundle model = SavedModelBundle.load("emotion_model", "serve")) {
            Tensor input = Tensor.create(new float[][] {{0.2f, 0.8f}});
            Tensor output = model.session().runner().feed("input", input).fetch("output").run().get(0);
            float[] predictions = output.copyTo(new float[1])[0];

            if (predictions[0] > 0.7) {
                System.out.println("긍정적인 감정 감지! 파일 저장 시작...");
                // 파일 저장 로직 실행
            }
        }
    }
}
```

✅ **인공지능이 인간의 감정을 분석하여 입출력을 자동으로 조절할 수 있음!**

---

# **📌 최종 정리: 자바 입출력의 마지막 진화**

| 단계 | 내용 |
| --- | --- |
| 32 | 클라우드 네이티브 I/O (Kubernetes + Java) |
| 33 | 양자 컴퓨팅 기반 데이터 전송 (Quantum I/O) |
| 34 | 인간-컴퓨터 인터페이스(HCI)와 I/O 결합 |
| 35 | AI와 인간 감정 기반 I/O |

🔥 **이제 진짜 "자바 I/O의 미래 전문가"가 되었습니다!**

이제 여러분은 **파일 시스템, 네트워크, 보안, 클라우드, AI, 양자 컴퓨팅까지 모두 다룰 수 있는 I/O 마스터**입니다. 🚀

---

💡 **다음 단계는?**
✅ **실제 기업 프로젝트에서 자바 I/O를 최적화하는 방법을 연구**

✅ **AI + I/O + 클라우드를 결합하여 차세대 애플리케이션 개발**

✅ **양자 컴퓨팅 기반의 새로운 보안 시스템 설계**

### 

---

# **📌 36단계 여기부터 록: 우주 데이터 전송 (Deep Space Communication)**

### **1. 지구와 화성 간 데이터 전송은 어떻게 할까?**

- 기존 I/O: **빛의 속도로도 20분 이상 걸리는 거리**
- NASA는 **레이저 기반 통신**을 연구 중!
- **자바로 우주 데이터 전송을 시뮬레이션할 수 있을까?**

📌 **예제: 레이저 기반 우주 데이터 전송 시뮬레이션**

```java
public class DeepSpaceTransmission {
    public static void main(String[] args) {
        double distanceToMars = 225_000_000; // km
        double speedOfLight = 299_792; // km/s

        double delay = distanceToMars / speedOfLight;
        System.out.println("지구 → 화성 데이터 전송 시간: " + delay + "초");

        if (delay > 20) {
            System.out.println("AI 예측 알고리즘을 사용하여 데이터 미리 전송...");
        }
    }
}
```

✅ **미래의 우주 데이터 전송을 위한 자바 기반 I/O 시뮬레이션 가능!** 🚀

---

# **📌 37단계: 뇌-컴퓨터 인터페이스(BCI)와 I/O 융합**

### **1. 인간의 뇌파를 직접 데이터로 변환할 수 있을까?**

- 기존 I/O: **키보드, 마우스, 터치스크린**
- 미래 I/O: **뇌에서 직접 데이터를 전송!** 🧠

📌 **예제: 뇌파(EEG) 데이터를 활용한 자바 I/O**

```java
java
복사편집
import com.neurosky.thinkgear.*;

public class BrainControlledIO {
    public static void main(String[] args) {
        TGDevice device = new TGDevice(new TGStreamReader());
        device.connect();

        device.addListener(new TGDeviceListener() {
            @Override
            public void onMeditationLevel(int level) {
                if (level > 80) {
                    System.out.println("집중도가 높음 → 파일 저장 실행!");
                    saveFile();
                }
            }
        });
    }

    public static void saveFile() {
        System.out.println("파일이 저장되었습니다!");
    }
}

```

✅ **뇌파 신호를 분석하여 자바 I/O를 직접 조작 가능!**

---

# **📌 38단계: 자바 I/O의 철학적 의미 – 정보 흐름과 인간의 역할**

### **1. 우리가 다룬 입출력은 결국 "정보의 흐름"**

- 인간도 **입출력(I/O) 시스템**이다!
- 우리는 데이터를 입력받고(학습), 출력한다(표현).
- 궁극적으로 **정보란 무엇인가?**

📌 **철학적 질문**

- **"자바 I/O와 인간의 사고 방식은 어떻게 연결될까?"**
- **"미래에는 인간이 직접 I/O가 될 수 있을까?"**
- **"기억과 정보, 그리고 AI는 어떤 관계일까?"**

✅ **정보의 흐름을 이해하면, 결국 모든 것은 I/O가 된다!**

---

# **📌 최종 단계: I/O의 끝을 넘어, 창조의 영역으로!**

| 단계 | 내용 |
| --- | --- |
| 36 | 우주 데이터 전송 (Deep Space I/O) |
| 37 | 뇌-컴퓨터 인터페이스(BCI)와 I/O 융합 |
| 38 | 자바 I/O의 철학적 의미 – 정보 흐름과 인간 |

🔥 **이제 당신은 단순한 개발자를 넘어, 기술 철학자이자 창조자가 되었습니다!** 🚀

---

💡 **이제 다음 목표는?**
✅ **I/O를 활용한 혁신적인 기술 개발**

✅ **미래의 정보 흐름을 예측하고 설계하는 역할**

✅ **기술과 인간, 그리고 우주의 연결을 연구**

# **📌 39단계: 멀티스레드 입출력 (병렬 I/O)**

대용량 파일을 읽을 때 **멀티스레드**를 활용하면 더 빠르게 처리할 수 있어요!

👉 **멀티스레드 I/O = CPU 여러 개 사용 = 속도 향상!**

📌 **예제: 멀티스레드로 파일 복사**

```java
import java.io.*;

class FileCopyThread extends Thread {
    private String source;
    private String destination;

    public FileCopyThread(String source, String destination) {
        this.source = source;
        this.destination = destination;
    }

    @Override
    public void run() {
        try (FileInputStream fis = new FileInputStream(source);
             FileOutputStream fos = new FileOutputStream(destination)) {

            byte[] buffer = new byte[1024 * 1024]; // 1MB 버퍼
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, bytesRead);
            }
            System.out.println(source + " -> " + destination + " 복사 완료!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

public class MultiThreadFileCopy {
    public static void main(String[] args) {
        String[] files = {"file1.mp4", "file2.mp4", "file3.mp4"};

        for (String file : files) {
            new FileCopyThread(file, "copy_" + file).start();
        }
    }
}
```

✅ **파일 3개를 동시에 복사! (멀티스레드로 속도 UP! 🚀)**

---

# **📌 40단계: 파일 감시 시스템 (WatchService)**

### **1. 실시간으로 폴더 변화를 감지하는 기능**

- 새로운 파일이 추가되었는지?
- 파일이 삭제되었는지?
- 파일이 수정되었는지?

📌 **예제: 특정 폴더를 감시하고 변화 감지**

```java
import java.nio.file.*;

public class DirectoryWatcher {
    public static void main(String[] args) throws Exception {
        WatchService watchService = FileSystems.getDefault().newWatchService();
        Path path = Paths.get("C:/myfolder");
        path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
                                      StandardWatchEventKinds.ENTRY_DELETE,
                                      StandardWatchEventKinds.ENTRY_MODIFY);

        System.out.println("폴더 감시 시작...");
        while (true) {
            WatchKey key = watchService.take();
            for (WatchEvent<?> event : key.pollEvents()) {
                System.out.println("이벤트 발생: " + event.kind() + " -> " + event.context());
            }
            key.reset();
        }
    }
}
```

✅ **파일이 추가/삭제/수정될 때 자동으로 감지 가능!**

---

# **📌 41단계: 메모리 매핑 파일 (Memory Mapped File)**

### **1. 초고속 파일 입출력을 원한다면?**

- 기존 `FileInputStream` 방식보다 **최대 10배 빠른 입출력 가능!** 🚀
- `MappedByteBuffer`를 사용해 **파일을 메모리에 매핑**하면 속도가 빨라짐.

📌 **예제: 초고속 파일 읽기**

```java
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

public class MemoryMappedFileExample {
    public static void main(String[] args) throws Exception {
        RandomAccessFile file = new RandomAccessFile("bigfile.txt", "r");
        FileChannel channel = file.getChannel();

        MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size());

        for (int i = 0; i < buffer.limit(); i++) {
            System.out.print((char) buffer.get()); // 파일 내용 출력
        }

        file.close();
    }
}
```

✅ **파일이 직접 메모리에 매핑되어 속도가 훨씬 빨라요!**

---

# **📌 42단계: 압축 & 해제 (ZIP 파일)**

### **1. 파일을 압축해서 저장 공간 절약하기**

자바의 `java.util.zip` 패키지를 활용하면 **ZIP 파일을 만들고 해제할 수 있어요.** 🎯

📌 **예제: ZIP 파일 만들기**

```java
import java.io.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipExample {
    public static void main(String[] args) throws IOException {
        FileOutputStream fos = new FileOutputStream("output.zip");
        ZipOutputStream zipOut = new ZipOutputStream(fos);

        File fileToZip = new File("largefile.txt");
        FileInputStream fis = new FileInputStream(fileToZip);

        ZipEntry zipEntry = new ZipEntry(fileToZip.getName());
        zipOut.putNextEntry(zipEntry);

        byte[] buffer = new byte[1024];
        int bytesRead;
        while ((bytesRead = fis.read(buffer)) != -1) {
            zipOut.write(buffer, 0, bytesRead);
        }

        fis.close();
        zipOut.closeEntry();
        zipOut.close();

        System.out.println("ZIP 파일 생성 완료!");
    }
```

✅ **대용량 파일을 ZIP으로 압축하면 공간을 절약할 수 있어요!**

---

# **📌 최종 정리**

| 단계 | 내용 |
| --- | --- |
| 39 | 멀티스레드 입출력 (병렬 처리) |
| 40 | 파일 감시 시스템 (WatchService) |
| 41 | 초고속 파일 입출력 (Memory Mapped File) |
| 42 | 파일 압축 & 해제 (ZIP) |

---

# **📌 43단계: 고급 파일 암호화 (AES-GCM)**

### **1. 보안이 중요한 데이터를 보호하려면?**

- 기존 **AES 암호화**보다 **더 강력한 AES-GCM** 방식 사용!
- 해커가 데이터를 변조하는 걸 막을 수 있음.

📌 **예제: AES-GCM을 사용한 파일 암호화**

```java
import javax.crypto.*;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.security.SecureRandom;
import java.util.Base64;

public class AESGCMFileEncryption {
    public static void main(String[] args) throws Exception {
        String key = "0123456789abcdef"; // 16바이트 키 (128비트)
        SecretKey secretKey = new SecretKeySpec(key.getBytes(), "AES");

        // 암호화
        byte[] iv = new byte[12]; // 12바이트 IV (초기 벡터)
        new SecureRandom().nextBytes(iv);
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, new GCMParameterSpec(128, iv));

        byte[] plainText = "비밀 데이터".getBytes();
        byte[] cipherText = cipher.doFinal(plainText);

        // 파일에 저장
        try (FileOutputStream fos = new FileOutputStream("encrypted.dat")) {
            fos.write(iv); // IV 저장
            fos.write(cipherText);
        }
        System.out.println("파일 암호화 완료!");
    }
}
```

✅ **AES-GCM을 활용하면 더 강력한 보안이 가능해요!**

---

# **📌 44단계: 데이터 직렬화 최적화 (Externalizable)**

### **1. 기본 직렬화는 속도가 느리다?**

- 기본 `Serializable` 방식은 **모든 필드를 자동 저장**해서 비효율적임.
- **`Externalizable`을 사용하면 원하는 필드만 저장**할 수 있어서 더 빠름!

📌 **예제: Externalizable을 사용한 직렬화**

```java
import java.io.*;

class User implements Externalizable {
    private String name;
    private int age;

    // 기본 생성자 필수!
    public User() {}

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 직접 직렬화할 필드 지정
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(name); // 문자열만 저장
    }

    // 직접 역직렬화할 필드 지정
    @Override
    public void readExternal(ObjectInput in) throws IOException {
        name = in.readUTF();
    }

    @Override
    public String toString() {
        return "이름: " + name + ", 나이: (저장 안 함)";
    }
}

public class ExternalizableExample {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        // 객체 직렬화
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("user.ser"));
        oos.writeObject(new User("홍길동", 30));
        oos.close();

        // 객체 역직렬화
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("user.ser"));
        User user = (User) ois.readObject();
        ois.close();

        System.out.println("복원된 객체: " + user);
    }
}
```

✅ **필요한 데이터만 직렬화하면 속도가 더 빠름!**

---

# **📌 45단계: 파일을 데이터베이스처럼 사용하기 (RandomAccessFile)**

### **1. 파일에서 특정 위치의 데이터만 수정할 수 있을까?**

- 기존 `FileReader`, `FileWriter`는 **처음부터 끝까지 읽어야 함**.
- **`RandomAccessFile`을 사용하면 원하는 위치의 데이터를 수정할 수 있음!**

📌 **예제: 파일 특정 위치의 데이터 수정**

```java
import java.io.RandomAccessFile;

public class RandomAccessFileExample {
    public static void main(String[] args) throws Exception {
        RandomAccessFile raf = new RandomAccessFile("data.txt", "rw");

        // 처음 10바이트 읽기
        byte[] buffer = new byte[10];
        raf.read(buffer);
        System.out.println("처음 10바이트: " + new String(buffer));

        // 파일의 5번째 위치부터 "HELLO" 삽입
        raf.seek(5);
        raf.write("HELLO".getBytes());

        raf.close();
        System.out.println("파일 수정 완료!");
    }
}
```

✅ **데이터베이스처럼 파일을 빠르게 수정 가능!**

---

# **📌 46단계: 로그 시스템 최적화 (Rolling Logs)**

### **1. 로그 파일이 너무 커지면 자동으로 새 로그 파일 만들기**

- **로그 파일이 10MB가 넘으면 새로운 로그 파일을 생성**
- 로그 데이터를 오래 보관하면서 저장 공간도 절약 가능!

📌 **예제: 자동 로그 롤링 시스템**

```java
import java.io.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class RollingLog {
    private static final long MAX_SIZE = 10 * 1024 * 1024; // 10MB

    public static void log(String message) throws IOException {
        File logFile = new File("log.txt");

        // 파일 크기 체크
        if (logFile.length() > MAX_SIZE) {
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            File newFile = new File("log_" + timestamp + ".txt");
            logFile.renameTo(newFile);
        }

        // 로그 쓰기
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(logFile, true))) {
            writer.write(LocalDateTime.now() + " - " + message);
            writer.newLine();
        }
    }

    public static void main(String[] args) throws IOException {
        log("서버 시작됨.");
        log("사용자가 로그인함.");
    }
}
```

✅ **로그 파일이 커지면 자동으로 새로운 파일을 생성!**

---

# **📌 47단계: 스트림을 활용한 실시간 데이터 처리 (Pipeline)**

### **1. 데이터를 여러 단계로 가공할 수 있을까?**

- **파일 → 압축 → 암호화 → 네트워크 전송** 같은 데이터 파이프라인 구축 가능!

📌 **예제: 데이터를 읽고, 압축하고, 네트워크로 전송하는 스트림 체이닝**

```java
import java.io.*;
import java.net.Socket;
import java.util.zip.GZIPOutputStream;

public class StreamPipelineExample {
    public static void main(String[] args) throws IOException {
        FileInputStream fis = new FileInputStream("data.txt");
        GZIPOutputStream gzipOut = new GZIPOutputStream(new FileOutputStream("data.gz"));
        BufferedOutputStream netOut = new BufferedOutputStream(new Socket("localhost", 5000).getOutputStream());

        byte[] buffer = new byte[1024];
        int bytesRead;
        while ((bytesRead = fis.read(buffer)) != -1) {
            gzipOut.write(buffer, 0, bytesRead); // 압축
            netOut.write(buffer, 0, bytesRead);  // 네트워크 전송
        }

        fis.close();
        gzipOut.close();
        netOut.close();
        System.out.println("데이터 처리 완료!");
    }
}
```

✅ **파일을 읽고, 압축하고, 네트워크로 보내는 파이프라인 구축 가능!**
