---
layout: post
title: "CHAP 3. 자바 if 문 개념"
date: 2025-05-17
categories: [backend, language, java]
tags: [backend, language, java]
thumbnail: /assets/img/post-thumbnails/intro2.png
author: Devchanny
---

# ** 📌 1단계 본문: 자바 `if` 문의 기본 개념**

---

## **1. `if` 문이란?**

- **`if` 문**은 **조건에 따라 코드가 실행될지 말지 결정**합니다.
- **조건이 참(`true`)이면** 코드 블록을 **실행**하고,
- **조건이 거짓(`false`)이면** **다음 코드로 건너뜁니다.**
- **조건에 따라 프로그램의 흐름을 제어**할 수 있습니다.

---

### **예시: `if` 문의 기본 구조**

```java
if (조건식) {
    // 조건식이 참일 때 실행할 코드
}
```

- `조건식`: **참(`true`) 또는 거짓(`false`)**이 나오는 식
- **조건식이 참일 때**만 **중괄호 `{}` 안의 코드**가 실행됩니다.

---

### **예시: `if` 문 사용법**

```java
int age = 20;
if (age >= 18) {
    System.out.println("성인입니다.");
}
```

- `age`가 **18 이상**일 때만 `"성인입니다."`가 출력됩니다.
- `age`가 **17 이하**라면 **아무것도 출력되지 않습니다.**

**🔹 비유: 신호등**

- **신호등이 초록불일 때만** 길을 건너고,
- **빨간불이면 멈춰 있는 것**과 같습니다.
- 조건(`age >= 18`)이 **초록불**일 때만 **코드가 실행**됩니다.

---

## **2. `if-else` 문이란?**

- `if` 문에 **`else` 문**을 붙이면 **조건이 거짓일 때 실행할 코드**를 작성할 수 있습니다.
- **조건이 참**이면 **`if` 블록**이 실행되고,
- **조건이 거짓**이면 **`else` 블록**이 실행됩니다.

---

### **예시: `if-else` 문 사용법**

```java
int age = 16;
if (age >= 18) {
    System.out.println("성인입니다.");
} else {
    System.out.println("미성년자입니다.");
}
```

- `age`가 **18 이상**이면 `"성인입니다."` 출력
- `age`가 **18 미만**이면 `"미성년자입니다."` 출력

**🔹 비유: 신호등 + 횡단보도 지킴이**

- **신호등이 초록불**이면 **길을 건너고**,
- **신호등이 빨간불**이면 **횡단보도 지킴이가 멈추라고 말함**
- 조건(`age >= 18`)이 **참일 때**는 `if` 코드가,
- 조건이 **거짓일 때**는 `else` 코드가 실행됨

---

## **3. `if-else if-else` 문이란?**

- **여러 개의 조건**을 검사할 때 사용합니다.
- **조건을 위에서부터 차례대로 검사**하고,
- **처음으로 참이 된 조건**의 **코드 블록**만 실행합니다.
- **조건이 모두 거짓**이면 **`else` 블록**이 실행됩니다.

---

### **예시: `if-else if-else` 문 사용법**

```java
int score = 85;

if (score >= 90) {
    System.out.println("A 학점");
} else if (score >= 80) {
    System.out.println("B 학점");
} else if (score >= 70) {
    System.out.println("C 학점");
} else {
    System.out.println("F 학점");
}
```

- `score`가 **90 이상**이면 `"A 학점"` 출력
- `score`가 **80 이상 90 미만**이면 `"B 학점"` 출력
- `score`가 **70 이상 80 미만**이면 `"C 학점"` 출력
- *그 외(70 미만)**이면 `"F 학점"` 출력

**🔹 비유: 학교 성적표**

- 점수(`score`)에 따라 **A, B, C, F 학점**을 받는 것과 같습니다.
- **첫 번째 조건**부터 순서대로 검사하고, **참이 된 조건**의 결과만 출력합니다.
- **조건이 겹칠 경우**, **먼저 만난 조건**만 실행되고 **나머지는 무시**됩니다.

---

### **중요! 조건 검사 순서**

- `if-else if-else` 문은 **위에서 아래로 조건을 차례대로 검사**합니다.
- **조건이 겹치는 경우** **먼저 만난 조건**만 실행되고 **나머지는 건너뜁니다.**
- 따라서 **자주 발생하는 조건**이나 **범위가 큰 조건**을 **먼저 검사**하는 것이 **성능에 유리**합니다.

---

### **조건이 겹칠 때 주의사항**

```java
int num = 10;

if (num > 5) {
    System.out.println("5보다 큽니다.");
} else if (num > 8) {
    System.out.println("8보다 큽니다.");
}
```

- `num`이 `10`일 때 **"5보다 큽니다."**만 출력되고,
- *"8보다 큽니다."**는 출력되지 않습니다.
- *첫 번째 조건(`num > 5`)**이 **참**이라서 **두 번째 조건은 건너뜁니다.**

---

## **4. 중첩 `if` 문이란?**

- **`if` 문 안에 또 다른 `if` 문**이 들어가는 구조입니다.
- 조건이 **여러 단계로 나누어져 있을 때** 사용합니다.
- 하지만 **중첩이 깊어질수록 가독성이 떨어지므로**
- *논리 연산자(`&&`, `||`)**로 **한 줄로 표현**하는 것이 좋습니다.

---

### **예시: 중첩 `if` 문 사용법**

```java
int age = 20;
boolean hasTicket = true;

if (age >= 18) {
    if (hasTicket) {
        System.out.println("영화관 입장 가능합니다.");
    }
}
```

- `age`가 **18 이상**이고,
- `hasTicket`이 **true**일 때만 **입장 가능**

### **중첩 대신 논리 연산자(`&&`) 사용하기**

```java
if (age >= 18 && hasTicket) {
    System.out.println("영화관 입장 가능합니다.");
}
```

- **`&&` 연산자**를 사용하여 **조건을 한 줄로 표현**
- **중첩 `if` 문보다 읽기 쉽고 간결**합니다.

---

## **5. 기술 면접 대비 요약**

- **`if` 문**: 조건이 **참일 때만 코드 실행**
- **`if-else` 문**: **참일 때**는 `if`, **거짓일 때**는 `else` 실행
- **`if-else if-else` 문**: **여러 조건**을 **순서대로 검사**
- **중첩 `if` 문**은 **가독성이 떨어지므로 논리 연산자(`&&`, `||`)** 사용 권장
- **조건 검사 순서**: **자주 발생하는 조건**을 **먼저 배치**하면 성능 최적화

---

# **⚡ 2단계 본문: `if-else` 문 성능 최적화**

---

## **1. 성능 최적화를 위한 `if-else` 사용법**

- **`if-else` 문**은 **위에서 아래로 순서대로 조건을 검사**합니다.
- 따라서 **자주 발생하는 조건**을 **먼저 배치**하면 **성능이 향상**됩니다.
- **거의 발생하지 않는 조건**은 **뒤쪽에 배치**합니다.

---

### **예시: 최적화 전**

```java
int num = 1;

if (num == 3) {
    System.out.println("숫자는 3입니다.");
} else if (num == 2) {
    System.out.println("숫자는 2입니다.");
} else if (num == 1) {
    System.out.println("숫자는 1입니다.");
}
```

- `num`이 `1`일 때, **모든 조건을 검사**한 후에야 마지막에 출력됩니다.
- **불필요한 연산이 많아서 비효율적**입니다.

---

### **예시: 최적화 후**

```java
int num = 1;

if (num == 1) {
    System.out.println("숫자는 1입니다.");
} else if (num == 2) {
    System.out.println("숫자는 2입니다.");
} else if (num == 3) {
    System.out.println("숫자는 3입니다.");
}
```

- *자주 발생하는 조건(`num == 1`)**을 **맨 위**에 배치합니다.
- 조건이 **참이면 다음 조건은 검사하지 않고 바로 실행**합니다.
- **연산 횟수를 줄여서 성능이 향상**됩니다.

**🔹 비유: 출입문 검사**

- **사람이 자주 출입하는 문**을 **가장 먼저 검사**하면 **대기 시간이 줄어듦**
- 자주 출입하지 않는 문은 **나중에 검사**해도 효율적임

---

## **2. `if-else if-else`에서 `switch` 문으로 최적화**

- **여러 개의 조건**을 검사할 때는 **`switch` 문**이 **성능이 더 좋을 수 있습니다.**
- `switch` 문은 **Jump Table**이라는 구조를 사용하여 **빠르게 분기**합니다.
- 특히 **정수, 문자열, enum** 같은 **고정된 값**을 비교할 때 유리합니다.

---

### **`if-else if-else` 문 예시**

```java
String fruit = "사과";

if (fruit.equals("사과")) {
    System.out.println("사과입니다.");
} else if (fruit.equals("바나나")) {
    System.out.println("바나나입니다.");
} else if (fruit.equals("딸기")) {
    System.out.println("딸기입니다.");
} else {
    System.out.println("알 수 없는 과일입니다.");
}
```

- **문자열**을 **여러 번 비교**해야 하므로 **비교 횟수가 많음**
- **모든 조건을 순서대로 검사**하므로 **성능이 떨어짐**

---

### **`switch` 문으로 최적화**

```java
String fruit = "사과";

switch (fruit) {
    case "사과" -> System.out.println("사과입니다.");
    case "바나나" -> System.out.println("바나나입니다.");
    case "딸기" -> System.out.println("딸기입니다.");
    default -> System.out.println("알 수 없는 과일입니다.");
}
```

- **`switch` 문**은 **Jump Table**을 사용하여 **빠르게 분기**
- **조건을 순서대로 검사하지 않고**, **해당 케이스로 바로 이동**
- **성능이 향상**되고 **가독성도 좋아짐**

**🔹 비유: 엘리베이터 층 선택**

- `if-else`는 **1층부터 순서대로 버튼을 누르며** 층을 확인
- `switch`는 **바로 해당 층 버튼**으로 **빠르게 이동**

---

## **3. `if` 문을 대체할 수 있는 방법**

### **1) 삼항 연산자 (? :) 사용하기**

- **`if-else` 문**이 **한 줄로 간단하게 표현**될 때 사용합니다.
- **조건 ? 참일 때 값 : 거짓일 때 값** 형태로 사용합니다.

```java
int age = 20;
String result = (age >= 18) ? "성인" : "미성년자";
System.out.println(result);  // 출력: 성인
```

- *조건(`age >= 18`)**이 **참이면 "성인"**, **거짓이면 "미성년자"**가 저장됩니다.
- **코드가 짧고 간결**해져서 **가독성이 좋아집니다.**

**🔹 비유: 스티커 붙이기**

- 나이가 `18` 이상이면 **"성인" 스티커**를,
- 나이가 `18` 미만이면 **"미성년자" 스티커**를 붙임

---

### **2) 다형성(Polymorphism)으로 대체하기**

- **조건문이 많거나** **확장 가능성이 큰 경우**에는
- *객체 지향 설계(OOP)**에서 **다형성(Polymorphism)**을 사용합니다.
- `if` 문 없이 **각 클래스에 개별 행동을 정의**하면,
- **유지보수성이 높아지고 확장하기 쉬워집니다.**

---

### **예시: 다형성으로 `if` 문 제거**

```java
abstract class Animal {
    abstract void makeSound();
}

class Dog extends Animal {
    void makeSound() { System.out.println("멍멍"); }
}

class Cat extends Animal {
    void makeSound() { System.out.println("야옹"); }
}

Animal pet = new Dog();
pet.makeSound();  // 출력: 멍멍
```

- **`if (pet == 개)`** 같은 조건문 없이,
- **Dog**와 **Cat** 클래스가 **각자 울음소리를 정의**합니다.
- 새로운 동물이 추가되어도 **`if` 문을 수정하지 않고**
- **클래스만 추가**하면 되므로 **확장성과 유지보수성**이 높아집니다.

**🔹 비유: 악기 연주하기**

- `Animal`은 **악기**이고, `Dog`와 `Cat`은 **기타와 피아노**
- *각 악기(클래스)**가 **각자의 소리(메서드)**를 냄
- *지휘자(`if` 문)**가 **일일이 지시하지 않아도**
- **각 악기가 알아서 소리를 냄**

---

## **4. 기술 면접 대비 요약**

- **자주 발생하는 조건**을 **먼저 배치**하여 `if-else` 최적화
- **여러 개의 조건문**은 **`switch` 문**으로 바꿔서 **Jump Table** 사용
- **간단한 조건문**은 **삼항 연산자(`? :`)**로 한 줄로 표현
- **복잡한 조건문**은 **다형성(Polymorphism)**으로 **확장성과 유지보수성** 향상
- **`if-else` 문**보다 **`switch` 문**이 성능이 좋은 경우도 있음

---

# **📐 3단계 본문: 중첩 `if` 문 줄이기**

---

## **1. 중첩 `if` 문이란?**

- **`if` 문 안에 또 다른 `if` 문**이 들어가는 구조입니다.
- **여러 단계의 조건**을 검사할 때 사용합니다.
- 하지만 **중첩이 깊어질수록 코드가 복잡하고 가독성이 떨어집니다.**

---

### **예시: 중첩 `if` 문 사용법**

```java
int age = 20;
boolean hasTicket = true;

if (age >= 18) {
    if (hasTicket) {
        System.out.println("영화관 입장 가능합니다.");
    }
}
```

- `age`가 **18 이상**이고,
- `hasTicket`이 **true**일 때만 **입장 가능**
- **조건이 두 단계**로 나누어져 있습니다.

**🔹 비유: 이중 잠금 장치**

- **문이 두 개**로 되어 있어서 **첫 번째 문(나이 확인)**을 열고,
- *두 번째 문(표 확인)**도 열어야 **입장 가능**
- **문이 여러 개라서 복잡하고 헷갈림**

---

## **2. 중첩 `if` 문을 줄이는 방법**

- *논리 연산자(`&&`, `||`)**를 사용하면 **한 줄로 표현**할 수 있습니다.
- **중첩을 줄여서** **가독성을 높이고** **성능도 최적화**됩니다.

---

### **방법 1: 논리 연산자(`&&`) 사용하기**

- **모든 조건이 참일 때**만 실행할 때는 **`&&` 연산자**를 사용합니다.
    - `조건1 && 조건2`: **둘 다 참**일 때만 **참**
- 위의 중첩 `if` 문을 **논리 연산자**로 변경하면 다음과 같습니다:
    
    ```java
    if (age >= 18 && hasTicket) {
        System.out.println("영화관 입장 가능합니다.");
    }
    ```
    
- **한 줄로 표현**하여 **가독성이 좋아지고**,
- **중첩을 없애서** **성능이 향상**됩니다.

**🔹 비유: 한 번에 두 가지 확인**

- **표 검사기**가 **나이와 표를 한 번에 검사**
- **두 개의 문을 열 필요 없이** **한 번에 입장**

---

### **방법 2: `return`이나 `break` 사용하기**

- **조건이 거짓일 때** **바로 리턴(return)하거나** **반복문을 빠져나옵니다.**
- **불필요한 조건 검사를 건너뛰어서 성능이 향상**됩니다.
- 주로 **메서드의 앞부분**에서 **조건을 검사하고 리턴**합니다.

---

### **예시: `return`으로 중첩 줄이기**

```java
void checkAge(int age) {
    if (age < 18) {
        System.out.println("미성년자는 입장할 수 없습니다.");
        return;
    }
    System.out.println("성인입니다. 입장 가능합니다.");
}
```

- **`age`가 18 미만이면** **바로 리턴**하여 **다음 코드를 건너뜁니다.**
- **중첩 없이** `if` 문을 **두 번 사용**하여 **가독성이 좋아집니다.**

**🔹 비유: 입구에서 돌려보내기**

- **미성년자**는 **입구에서 바로 돌려보내기**
- **성인만** **다음 단계(입장 검사)**로 이동

---

### **예시: `break`로 중첩 줄이기 (반복문에서 사용)**

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;  // i가 5일 때 반복문을 빠져나옴
    }
    System.out.println(i);
}
```

- `i`가 `5`일 때 **`break`*로 **반복문을 빠져나옵니다.**
- **중첩 없이** **필요한 조건만 검사**합니다.
- *`break`*는 **반복문에서만 사용**할 수 있습니다.

**🔹 비유: 정해진 번호에서 멈추기**

- **5번 손님**이 오면 **가게 문을 닫고 영업 종료**
- **다음 손님은 검사하지 않고 건너뜀**

---

## **3. `if-else` 문을 삼항 연산자(? :)로 간단하게 표현하기**

- **`if-else` 문**이 **한 줄로 표현 가능**할 때는
- *삼항 연산자(`? :`)**를 사용하면 **가독성이 좋아집니다.**
- **형식**: `조건 ? 참일 때 값 : 거짓일 때 값`

---

### **예시: 삼항 연산자 사용하기**

```java
int age = 20;
String result = (age >= 18) ? "성인" : "미성년자";
System.out.println(result);  // 출력: 성인
```

- `age`가 `18 이상`이면 `"성인"`을 저장하고,
- 그렇지 않으면 `"미성년자"`를 저장합니다.
- **한 줄로 표현**하여 **코드가 짧고 간결**합니다.

**🔹 비유: 빨간 스티커, 파란 스티커**

- 나이가 `18` 이상이면 **빨간 스티커(성인)**,
- 나이가 `18` 미만이면 **파란 스티커(미성년자)**

---

## **4. 기술 면접 대비 요약**

- **중첩 `if` 문**은 **논리 연산자(`&&`, `||`)**로 **한 줄로 표현**
- **조건이 거짓일 때** **`return`이나 `break`*로 **바로 건너뛰기**
- *삼항 연산자(`? :`)**를 사용하면 **간단한 `if-else` 문**을 **한 줄로 표현**
- **가독성을 높이고** **성능도 최적화**됨
- **중첩이 깊어질수록 가독성이 떨어지고 성능이 저하**되므로 **줄이는 것이 좋음**

---

### **📝 한눈에 보는 요약**

- **논리 연산자(`&&`, `||`)**: **중첩 없이 한 줄로 표현**
- **`return`과 `break`**: **조건이 거짓일 때** **바로 종료**
- **삼항 연산자(? :)**: **간단한 `if-else` 문을 한 줄로**
- **중첩을 줄이면** **가독성이 좋아지고 성능도 향상**됨

---

---

# **🔄 4단계 본문: `switch` 문과 `if-else if-else` 비교**

---

## **1. `switch` 문이란?**

- **하나의 변수**에 대해 **여러 개의 값을 비교**할 때 사용합니다.
- **`if-else if-else` 문**과 비슷하지만,
- **조건이 고정된 값일 때 더 효율적**입니다.
- **정수, 문자열, enum** 같은 **정해진 값**을 비교할 때 유리합니다.

---

### **`switch` 문 기본 구조**

```java
switch (변수) {
    case 값1 -> 실행 코드;
    case 값2 -> 실행 코드;
    default -> 기본 실행 코드;
}
```

- **`변수`**: **비교할 대상**
- **`case`**: **비교할 값** (고정된 값)
- **`default`**: **모든 case에 해당하지 않을 때** 실행

---

### **예시: `switch` 문 사용법**

```java
int day = 3;

switch (day) {
    case 1 -> System.out.println("월요일");
    case 2 -> System.out.println("화요일");
    case 3 -> System.out.println("수요일");
    case 4 -> System.out.println("목요일");
    case 5 -> System.out.println("금요일");
    default -> System.out.println("주말");
}
```

- `day`가 `3`이면 `"수요일"` 출력
- `day`가 `1 ~ 5`가 아니면 `"주말"` 출력

**🔹 비유: 다중 선택 문제**

- `day`라는 문제에 대해 **1, 2, 3, 4, 5 중 하나의 정답**을 고르는 것과 비슷
- **정답이 정해져 있어서** **빠르게 선택**할 수 있음

---

## **2. `if-else if-else` 문과 비교**

- **`if-else if-else` 문**은 **조건을 순서대로 검사**합니다.
- **`switch` 문**은 **Jump Table**을 사용하여 **해당 케이스로 바로 이동**합니다.
- **고정된 값**을 비교할 때는 **`switch` 문이 더 빠르고 가독성도 좋습니다.**

---

### **`if-else if-else` 문 예시**

```java
int day = 3;

if (day == 1) {
    System.out.println("월요일");
} else if (day == 2) {
    System.out.println("화요일");
} else if (day == 3) {
    System.out.println("수요일");
} else if (day == 4) {
    System.out.println("목요일");
} else if (day == 5) {
    System.out.println("금요일");
} else {
    System.out.println("주말");
}
```

- `day`가 `3`이면,
- `1`, `2` 조건을 **순서대로 검사한 후**에야 `"수요일"`을 출력합니다.
- **조건을 순차적으로 검사**하기 때문에 **비교 횟수가 많음**

**🔹 비유: 줄 서서 검사받기**

- 사람(`day`)이 **1번 창구**부터 차례대로 검사
- *정답(3번)**을 만나기 전까지 **모든 창구**를 거침
- **줄 서서 기다리느라 비효율적**

---

### **`switch` 문으로 최적화**

```java
int day = 3;

switch (day) {
    case 1 -> System.out.println("월요일");
    case 2 -> System.out.println("화요일");
    case 3 -> System.out.println("수요일");
    case 4 -> System.out.println("목요일");
    case 5 -> System.out.println("금요일");
    default -> System.out.println("주말");
}
```

- `switch` 문은 **Jump Table**을 사용합니다.
- `day`가 `3`이면 **바로 3번 케이스**로 **빠르게 이동**합니다.
- **조건을 순차적으로 검사하지 않으므로** **성능이 더 좋습니다.**

**🔹 비유: 엘리베이터 버튼**

- `switch`는 **엘리베이터 버튼처럼**
- **눌린 층(3층)으로 바로 이동**
- **중간 층을 거치지 않음**

---

## **3. `switch` 문의 장점**

- **Jump Table** 덕분에 **빠르게 분기**합니다.
- **정수, 문자열, enum**처럼 **고정된 값**을 비교할 때 **효율적**입니다.
- **가독성이 좋아지고 코드가 간결**해집니다.

---

## **4. `switch` 문의 단점**

- **조건이 복잡하거나 범위가 필요한 경우**에는 사용할 수 없습니다.
- 예: `day > 0 && day < 6` 같은 **범위 비교는 `if` 문만 가능**
- **모든 case가 독립적**이므로 **중복 코드를 줄이기 어렵습니다.**
    
    ```java
    switch (day) {
        case 1, 2, 3, 4, 5 -> System.out.println("평일");
        default -> System.out.println("주말");
    }
    ```
    
- **JDK 12 이상**에서는 **여러 case를 쉼표(,)로 묶을 수 있습니다.**

---

## **5. 언제 `switch` 문을 사용해야 할까?**

- **정해진 값**을 비교할 때 사용 (예: `int`, `String`, `enum`)
- **값이 고정적**이고 **조건이 많을 때** 사용하면 **성능이 좋아집니다.**
- **범위 검사**가 필요하거나 **복잡한 조건**이 있을 때는 **`if-else` 문** 사용

---

### **예시: `switch` 문이 적합한 경우**

```java
enum Level { BEGINNER, INTERMEDIATE, ADVANCED }

Level myLevel = Level.INTERMEDIATE;

switch (myLevel) {
    case BEGINNER -> System.out.println("초보자");
    case INTERMEDIATE -> System.out.println("중급자");
    case ADVANCED -> System.out.println("고급자");
}
```

- `enum` 타입은 **고정된 값**이므로 **`switch` 문이 적합**합니다.
- **`if-else` 문보다 가독성이 좋고, 성능도 빠릅니다.**

---

## **6. 기술 면접 대비 요약**

- **`switch` 문**은 **Jump Table**을 사용하여 **빠르게 분기**
- **고정된 값**(`int`, `String`, `enum`)을 비교할 때 **성능이 좋음**
- *`if-else if-else`*는 **조건을 순서대로 검사** → **비교 횟수가 많음**
- **범위 비교** 또는 **복잡한 조건**은 **`if-else` 문** 사용
- **JDK 12 이상**에서는 **여러 case를 쉼표(,)**로 묶을 수 있음
- **조건이 많고 고정된 값**일 때는 **`switch` 문이 더 빠르고 가독성도 좋음**

# **🧩 5단계 본문: 다형성으로 `if` 문 대체하기**

---

## **1. 다형성(Polymorphism)이란?**

- *다형성(Polymorphism)**은 **하나의 메서드나 객체가 여러 가지 형태를 가질 수 있는 성질**입니다.
- **같은 메서드 이름**이라도 **다른 클래스에서 다르게 동작**합니다.
- **`if` 문이나 `switch` 문을 사용하지 않고**,
- **각 클래스에서 개별 행동**을 정의하여 **확장성과 유지보수성을 높일 수 있습니다.**

---

### **다형성의 특징 요약**

- *상속(Inheritance)**과 **오버라이딩(Overriding)**을 사용합니다.
- **부모 클래스 타입**의 변수로 **자식 클래스 객체**를 참조할 수 있습니다.
- **메서드를 호출할 때** **자식 클래스의 오버라이딩된 메서드**가 실행됩니다.
- **조건문 없이** **각 클래스에서 행동을 정의**하므로 **확장성과 유지보수성**이 높아집니다.

---

## **2. 다형성을 사용한 예시: 동물 울음소리**

- **`if` 문을 사용하면** **조건이 많아질수록 코드가 복잡해집니다.**
- 예를 들어, 개와 고양이, 소가 울음소리를 낸다고 할 때:

---

### **`if` 문을 사용한 예시 (유지보수성 낮음)**

```java
String animal = "개";

if (animal.equals("개")) {
    System.out.println("멍멍");
} else if (animal.equals("고양이")) {
    System.out.println("야옹");
} else if (animal.equals("소")) {
    System.out.println("음매");
} else {
    System.out.println("알 수 없는 동물");
}
```

- **새로운 동물이 추가되면** **`if` 문을 수정해야 함**
- **조건이 많아질수록 코드가 복잡**해짐
- **가독성과 유지보수성**이 **떨어집니다.**

---

### **다형성을 사용한 예시 (유지보수성 높음)**

- *부모 클래스(`Animal`)**와 **자식 클래스(`Dog`, `Cat`, `Cow`)**를 만듭니다.
- **각 자식 클래스**에서 **울음소리를 정의**합니다.
- **새로운 동물이 추가되더라도 `if` 문을 수정하지 않고**
- **클래스만 추가**하면 됩니다.

```java
// 부모 클래스
abstract class Animal {
    abstract void makeSound();
}

// 자식 클래스 - 개
class Dog extends Animal {
    void makeSound() { System.out.println("멍멍"); }
}

// 자식 클래스 - 고양이
class Cat extends Animal {
    void makeSound() { System.out.println("야옹"); }
}

// 자식 클래스 - 소
class Cow extends Animal {
    void makeSound() { System.out.println("음매"); }
}

// 메인 메서드
public class Main {
    public static void main(String[] args) {
        Animal myPet = new Dog();
        myPet.makeSound();  // 출력: 멍멍

        myPet = new Cat();
        myPet.makeSound();  // 출력: 야옹

        myPet = new Cow();
        myPet.makeSound();  // 출력: 음매
    }
}
```

---

### **설명**

- *부모 클래스(`Animal`)**에는 **추상 메서드(`makeSound()`)**만 있습니다.
- *자식 클래스(`Dog`, `Cat`, `Cow`)**는 **각각의 울음소리**를 **오버라이딩**합니다.
- **`if` 문 없이** **각 클래스가 알아서 행동**합니다.
- **새로운 동물**이 생겨도 **클래스만 추가**하면 되므로 **확장성과 유지보수성**이 높습니다.

**🔹 비유: 지휘자와 악기**

- *지휘자(`Animal`)**는 **악기마다 어떤 소리가 나는지 모름**
- *각 악기(`Dog`, `Cat`, `Cow`)**가 **각자의 소리**를 냄
- **새로운 악기**가 추가되더라도 **지휘자는 신경 쓰지 않음**

---

## **3. 다형성을 사용한 이점**

- **조건문 없이** **각 클래스가 행동**을 정의하므로 **가독성이 좋아집니다.**
- **새로운 클래스가 추가되더라도** **기존 코드를 수정할 필요가 없습니다.**
- **확장성과 유지보수성**이 **높아집니다.**
- **`if-else` 문이 많아질 때**는 **다형성**으로 바꾸면 **코드가 깔끔해집니다.**

---

## **4. 다형성의 다른 활용 예: 계산기**

- **연산자에 따라 다른 계산**을 해야 할 때도 **다형성**을 사용할 수 있습니다.
- 예를 들어, **덧셈, 뺄셈, 곱셈, 나눗셈**을 하는 계산기:

---

### **`if-else` 문을 사용한 예시 (유지보수성 낮음)**

```java
String operator = "+";
int a = 10;
int b = 5;
int result;

if (operator.equals("+")) {
    result = a + b;
} else if (operator.equals("-")) {
    result = a - b;
} else if (operator.equals("*")) {
    result = a * b;
} else if (operator.equals("/")) {
    result = a / b;
} else {
    throw new IllegalArgumentException("잘못된 연산자");
}

System.out.println("결과: " + result);
```

- **연산자가 추가되거나 변경되면** **`if` 문을 수정해야 함**
- **조건이 많아질수록 코드가 복잡**해짐

---

### **다형성을 사용한 예시 (유지보수성 높음)**

```java
// 부모 클래스 - 연산자
abstract class Operator {
    abstract int calculate(int a, int b);
}

// 자식 클래스 - 덧셈
class Addition extends Operator {
    int calculate(int a, int b) {
        return a + b;
    }
}

// 자식 클래스 - 뺄셈
class Subtraction extends Operator {
    int calculate(int a, int b) {
        return a - b;
    }
}

// 메인 메서드
public class Main {
    public static void main(String[] args) {
        Operator op = new Addition();
        System.out.println(op.calculate(10, 5));  // 출력: 15

        op = new Subtraction();
        System.out.println(op.calculate(10, 5));  // 출력: 5
    }
}
```

- **연산자가 추가되더라도** **클래스만 추가**하면 됩니다.
- **`if` 문을 수정하지 않고** **확장할 수 있습니다.**
- **다형성 덕분에 유지보수성이 높아지고 가독성도 좋아집니다.**

---

## **5. 기술 면접 대비 요약**

- *다형성(Polymorphism)**은 **`if` 문 없이** **각 클래스가 행동**을 정의
- **확장성과 유지보수성**이 **높아집니다.**
- **조건이 많고 복잡한 경우**에는 **다형성**을 사용하면 **코드가 깔끔해짐**
- **새로운 기능이 추가될 때** **기존 코드를 수정하지 않고** **클래스만 추가**
- **가독성이 좋아지고 코드가 유연**해짐

---

---

# **⚡ 6단계 본문: Short-Circuiting (단축 평가)와 논리 연산자**

---

## **1. Short-Circuiting(단축 평가)란?**

- *Short-Circuiting(단축 평가)**는 **논리 연산자(`&&`, `||`)**에서 **왼쪽 조건만으로 결과가 결정되면**
- **오른쪽 조건은 평가하지 않는** **최적화 기법**입니다.
- **불필요한 연산을 생략**하여 **성능을 최적화**할 수 있습니다.
- **코드를 더 간결하고 효율적으로** 만들 수 있습니다.

---

### **예시: `&&` 연산자의 Short-Circuiting**

```java
int num = 10;

if (num > 0 && num < 5) {
    System.out.println("0보다 크고 5보다 작습니다.");
}
```

- `num > 0`이 **참(true)**이면 **두 번째 조건**을 검사합니다.
- `num > 0`이 **거짓(false)**이면 **`&&` 특성상 전체가 거짓**이므로
- **`num < 5`는 검사하지 않고 건너뜁니다.**
- **불필요한 연산을 생략**해서 **성능이 향상**됩니다.

**🔹 비유: 첫 번째 문에서 통과하지 못하면 다음 문을 열지 않음**

- **첫 번째 문**을 통과해야 **두 번째 문**으로 갈 수 있음
- **첫 번째 문에서 막히면** **두 번째 문은 열리지 않음**
- **필요 없는 문 검사를 생략**해서 **시간을 절약**

---

### **예시: `||` 연산자의 Short-Circuiting**

```java
int num = 10;

if (num > 20 || num < 15) {
    System.out.println("20보다 크거나 15보다 작습니다.");
}
```

- `num > 20`이 **거짓(false)**이면 **두 번째 조건**을 검사합니다.
- `num > 20`이 **참(true)**이면 **`||` 특성상 전체가 참**이므로
- **`num < 15`는 검사하지 않고 건너뜁니다.**
- **불필요한 연산을 생략**해서 **성능이 향상**됩니다.

**🔹 비유: 첫 번째 문에서 통과하면 두 번째 문은 열 필요 없음**

- **첫 번째 문**에서 **통과하면 바로 입장**
- **두 번째 문은 열지 않음**
- **필요 없는 문 검사를 생략**해서 **시간을 절약**

---

## **2. 논리 연산자의 특징 요약**

| **연산자** | **설명** | **Short-Circuiting** | **예시** |
| --- | --- | --- | --- |
| **`&&` (AND)** | **모두 참일 때만** 참 | **왼쪽이 거짓이면 오른쪽 생략** | `a > 0 && b > 0` |
| **`||` (OR)** | 둘중 하나라도 참이면 참 | ` (OR)** | `a > 0 || b > 0` |
| **`!` (NOT)** | **참 → 거짓**, **거짓 → 참** | 없음 | `!(a > 0)` |

---

### **논리 연산자의 평가 순서**

- 자바는 **왼쪽에서 오른쪽 순서로** 조건을 검사합니다.
- **Short-Circuiting**은 **왼쪽 조건만으로 결과가 결정되면**
- **오른쪽 조건은 검사하지 않습니다.**

---

### **예시: 순서에 따른 Short-Circuiting**

```java
int num = 10;

if (num > 0 && num++ < 20) {
    System.out.println("조건이 참입니다.");
}
System.out.println(num);  // 출력: 11
```

- `num > 0`이 **참**이므로 **`num++ < 20`*도 검사합니다.
- `num++`이 **실행**되어 **`num`이 11로 증가**합니다.

---

```java
int num = -10;

if (num > 0 && num++ < 20) {
    System.out.println("조건이 참입니다.");
}
System.out.println(num);  // 출력: -10
```

- `num > 0`이 **거짓**이므로 **Short-Circuiting** 발생
- *`num++ < 20`*는 **검사하지 않고 건너뜁니다.**
- 따라서 **`num`은 그대로 -10**입니다.

**🔹 비유: 첫 번째 문이 잠겨 있으면 두 번째 문을 열지 않음**

- **첫 번째 문**을 **열지 못하면**
- **두 번째 문**은 **확인하지도 않음**
- **필요 없는 행동을 생략**해서 **시간을 절약**

---

## **3. Short-Circuiting으로 코드 최적화하기**

- **`if` 문 안에서** **NullPointerException**을 방지할 때 유용합니다.
- **`&&` 연산자**의 **Short-Circuiting**을 활용하면
- **왼쪽 조건이 거짓일 때** **오른쪽 조건을 검사하지 않음**을 이용합니다.

---

### **예시: NullPointerException 방지**

```java
String str = null;

if (str != null && str.length() > 0) {
    System.out.println("문자열 길이: " + str.length());
}
```

- `str`이 **`null`일 때**
- `str.length()`를 호출하면 **NullPointerException** 발생
- 그러나 **`str != null`이 거짓**이므로
- **Short-Circuiting**이 발생하고 **`str.length()`는 검사하지 않음**
- **NullPointerException 없이 안전하게 실행**됩니다.

**🔹 비유: 문이 닫혀 있으면 안쪽 방은 보지 않음**

- **첫 번째 문이 닫혀 있으면**
- **안쪽 방은 확인하지 않음**
- **안전을 확인하고 행동**하기 때문에 **문제가 발생하지 않음**

---

## **4. Short-Circuiting의 주의점**

- **Short-Circuiting**은 **왼쪽 조건만으로 결과가 결정되면**
- **오른쪽 조건은 검사하지 않기 때문에**
- **오른쪽 조건에 중요한 로직이 있을 때는 사용하면 안 됩니다.**

---

### **예시: Short-Circuiting의 주의점**

```java
int num = 10;

if (num > 20 && ++num < 15) {
    System.out.println("조건이 참입니다.");
}
System.out.println(num);  // 출력: 10
```

- `num > 20`이 **거짓**이므로
- **Short-Circuiting**이 발생하고 **`++num < 15`는 실행되지 않음**
- 따라서 **`num`은 11로 증가하지 않고 그대로 10**입니다.
- **오른쪽 조건**에 **중요한 로직(`++num`)이 있다면**
- **Short-Circuiting 때문에 실행되지 않을 수 있으므로 주의**해야 합니다.

---

## **5. 기술 면접 대비 요약**

- **Short-Circuiting(단축 평가)**:
    - **`&&`**: **왼쪽이 거짓이면 오른쪽 생략**
    - **`||`**: **왼쪽이 참이면 오른쪽 생략**
- **불필요한 연산 생략** → **성능 최적화**
- **NullPointerException 방지**에 유용
- **오른쪽 조건에 중요한 로직이 있을 때는 사용하지 말 것**
- **왼쪽에서 오른쪽 순서로 평가**됨

---

---

# **🎓 7단계 본문: 기술 면접 대비 요약 - 자바 `if` 문 최적화**

---

## **1. 자주 발생하는 조건을 먼저 배치하기**

- **`if-else` 문**은 **위에서 아래로 순서대로 조건을 검사**합니다.
- **자주 발생하는 조건**을 **먼저 배치**하면 **불필요한 조건 검사를 줄여서 성능이 향상**됩니다.
- **거의 발생하지 않는 조건**은 **뒤쪽에 배치**합니다.

---

### **예시: 자주 발생하는 조건을 먼저 배치**

```java
int num = 1;

if (num == 1) {
    System.out.println("숫자는 1입니다.");
} else if (num == 2) {
    System.out.println("숫자는 2입니다.");
} else if (num == 3) {
    System.out.println("숫자는 3입니다.");
}
```

- **`num`이 `1`일 가능성이 높다면** **맨 위에 배치**합니다.
- **첫 번째 조건이 참**이면 **나머지 조건은 검사하지 않음**
- **연산 횟수를 줄여서 성능이 향상**됩니다.

**🔹 비유: 출입문 검사**

- **사람이 자주 출입하는 문**을 **가장 먼저 검사**하면 **대기 시간이 줄어듦**
- 자주 출입하지 않는 문은 **나중에 검사**해도 효율적임

---

## **2. `switch` 문으로 최적화하기**

- **여러 개의 조건**을 검사할 때는 **`switch` 문**이 **성능이 더 좋을 수 있습니다.**
- `switch` 문은 **Jump Table**을 사용하여 **빠르게 분기**합니다.
- 특히 **정수, 문자열, enum** 같은 **고정된 값**을 비교할 때 유리합니다.

---

### **예시: `switch` 문으로 최적화**

```java
String fruit = "사과";

switch (fruit) {
    case "사과" -> System.out.println("사과입니다.");
    case "바나나" -> System.out.println("바나나입니다.");
    case "딸기" -> System.out.println("딸기입니다.");
    default -> System.out.println("알 수 없는 과일입니다.");
}
```

- **`switch` 문**은 **Jump Table**을 사용하여 **해당 케이스로 바로 이동**
- **조건을 순서대로 검사하지 않고**, **해당 케이스로 빠르게 이동**
- **성능이 향상**되고 **가독성도 좋아짐**

**🔹 비유: 엘리베이터 버튼**

- `switch`는 **엘리베이터 버튼처럼**
- **눌린 층(3층)으로 바로 이동**
- **중간 층을 거치지 않음**

---

## **3. 중첩 `if` 문 최소화하기**

- **중첩 `if` 문**은 **가독성이 떨어지고 성능 저하**를 유발합니다.
- *논리 연산자(`&&`, `||`)**를 사용하면 **한 줄로 표현**할 수 있습니다.
- **중첩을 줄여서** **가독성을 높이고** **성능도 최적화**됩니다.

---

### **예시: 논리 연산자로 중첩 줄이기**

```java
int age = 20;
boolean hasTicket = true;

if (age >= 18 && hasTicket) {
    System.out.println("영화관 입장 가능합니다.");
}
```

- **`&&` 연산자**를 사용하여 **조건을 한 줄로 표현**
- **중첩 `if` 문보다 읽기 쉽고 간결**합니다.

**🔹 비유: 한 번에 두 가지 확인**

- **표 검사기**가 **나이와 표를 한 번에 검사**
- **두 개의 문을 열 필요 없이** **한 번에 입장**

---

## **4. 다형성(Polymorphism)으로 확장성과 유지보수성 높이기**

- **조건문이 많거나** **확장 가능성이 큰 경우**에는
- *객체 지향 설계(OOP)**에서 **다형성(Polymorphism)**을 사용합니다.
- `if` 문 없이 **각 클래스에 개별 행동을 정의**하면,
- **유지보수성이 높아지고 확장하기 쉬워집니다.**

---

### **예시: 다형성으로 `if` 문 제거**

```java
abstract class Animal {
    abstract void makeSound();
}

class Dog extends Animal {
    void makeSound() { System.out.println("멍멍"); }
}

class Cat extends Animal {
    void makeSound() { System.out.println("야옹"); }
}

Animal pet = new Dog();
pet.makeSound();  // 출력: 멍멍
```

- **`if` 문 없이** **각 클래스가 알아서 행동**합니다.
- **새로운 동물**이 생겨도 **클래스만 추가**하면 되므로 **확장성과 유지보수성**이 높습니다.

**🔹 비유: 악기 연주하기**

- `Animal`은 **악기**이고, `Dog`와 `Cat`은 **기타와 피아노**
- *각 악기(클래스)**가 **각자의 소리(메서드)**를 냄
- *지휘자(`if` 문)**가 **일일이 지시하지 않아도**
- **각 악기가 알아서 소리를 냄**

---

## **5. Short-Circuiting(단축 평가)로 성능 최적화**

- **`&&`와 `||` 연산자**는 **왼쪽 조건만으로 결과가 결정되면**
- **오른쪽 조건은 평가하지 않습니다.**
- **불필요한 연산을 생략**하여 **성능 향상**됩니다.

---

### **예시: Short-Circuiting(단축 평가)**

```java
String str = null;

if (str != null && str.length() > 0) {
    System.out.println("문자열 길이: " + str.length());
}
```

- `str`이 **`null`일 때**
- `str.length()`를 호출하면 **NullPointerException** 발생
- 그러나 **`str != null`이 거짓**이므로
- **Short-Circuiting**이 발생하고 **`str.length()`는 검사하지 않음**
- **NullPointerException 없이 안전하게 실행**됩니다.

**🔹 비유: 문이 닫혀 있으면 안쪽 방은 보지 않음**

- **첫 번째 문이 닫혀 있으면**
- **안쪽 방은 확인하지 않음**
- **안전을 확인하고 행동**하기 때문에 **문제가 발생하지 않음**

---

## **6. 기술 면접 대비 요약**

- **자주 발생하는 조건**을 **먼저 배치**하여 성능 최적화
- **`switch` 문**은 **Jump Table**을 사용하여 **다중 조건 빠르게 처리**
- **중첩 `if` 문 최소화**: **논리 연산자(`&&`, `||`)**로 단순화
- **다형성 적용**: **확장성과 유지보수성 향상**
- **Short-Circuiting**: **불필요한 연산 생략**으로 **성능 최적화**

---
