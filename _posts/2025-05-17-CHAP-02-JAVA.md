---
layout: post
title: "CHAP 2. 자바 형변환과 메모리 개념 총정리"
date: 2025-05-17
categories: [backend, language, java]
tags: [backend, language, java]
thumbnail: /assets/img/post-thumbnails/intro1.png
author: Devchanny
---

# **📌 1단계 본문: 기본형과 참조형이란?**

---

## **1. 기본형(Primitive Type)이란?**

- **숫자, 문자, 참/거짓** 같은 **간단한 값**을 저장하는 **변수**입니다.
- **값 자체**가 저장됩니다.
- **컴퓨터의 Stack(스택) 메모리**에 저장되며, **메서드가 끝나면 자동으로 사라집니다.**

---

### **예시 1: 숫자 저장**

```java
int age = 10;
```

- `int`: **정수형** 타입 (소수점 없는 숫자)
- `age`: **변수 이름** (숫자를 저장할 상자 이름)
- `10`: **저장된 값** (age라는 상자 안에 10이 들어 있음)

**🔹 비유: 상자에 숫자 종이 넣기**

- `age`라는 이름표가 붙은 **상자**에 **"10"이라고 적힌 종이**가 들어 있음
- 상자 안에는 **숫자 값 자체**가 저장됨

---

### **예시 2: 문자와 참/거짓**

```java
char grade = 'A';
boolean isActive = true;
```

- `char`: **문자형** 타입 (한 글자)
- `boolean`: **참/거짓형** 타입 (`true` 또는 `false`만 저장)

**🔹 비유: 상자에 글자 종이 넣기**

- `grade`라는 상자에는 **"A"라고 적힌 종이**가 들어 있음
- `isActive`라는 상자에는 **"참(True)"**라고 적힌 종이

---

### **정리: 기본형 변수의 특징**

- 값을 저장할 때 **상자에 직접 넣는 것**과 같음
- **값 자체**가 상자 안에 들어감
- 상자가 **Stack 메모리**에 쌓이고, **프로그램이 끝나면 자동으로 사라짐**

---

## **2. 참조형(Reference Type)이란?**

- `String`, `배열(Array)`, `클래스(Class)` 같은 **복잡한 데이터**를 저장
- **값 자체가 아닌 "주소"를 저장**합니다.
- **Heap(힙) 메모리**에 저장되고, **가비지 컬렉터(GC)**가 사용하지 않는 데이터를 정리합니다.

---

### **예시 1: 문자열(String) 저장**

```java
String name = "홍길동";
```

- `String`: **문자열** 타입 (여러 글자를 한 번에 저장)
- `name`: **변수 이름** (문자열을 저장할 상자 이름)
- `"홍길동"`: **저장된 값** (이름이 홍길동인 사람)

**🔹 비유: 주소가 적힌 종이**

- `name` 상자에는 `"홍길동"`이 **직접 들어있는 게 아니라**
- `"홍길동"`이 저장된 **Heap 메모리의 주소**가 적힌 **지도 같은 종이**가 들어 있음

---

### **예시 2: 배열(Array) 저장**

```java
int[] scores = {90, 85, 95};
```

- `int[]`: **정수 배열** 타입 (여러 개의 숫자를 한 번에 저장)
- `scores`: **변수 이름** (배열을 저장할 상자 이름)
- `{90, 85, 95}`: **저장된 값** (점수 3개)

**🔹 비유: 주소가 적힌 지도**

- `scores` 상자에는 `90, 85, 95`가 **직접 들어있는 게 아니고**
- 이 값들이 저장된 **Heap 메모리의 주소**가 적힌 **지도 같은 종이**가 들어 있음

---

### **정리: 참조형 변수의 특징**

- **Heap 메모리**에 **실제 데이터**가 저장됨
- 변수에는 **Heap 메모리의 주소**가 저장됨 (즉, **지도**가 들어 있는 것)
- *가비지 컬렉터(GC)**가 **사용하지 않는 Heap 메모리**를 자동으로 정리

---

## **3. 기본형과 참조형의 차이점 요약**

| **구분** | **기본형(Primitive Type)** | **참조형(Reference Type)** |
| --- | --- | --- |
| **저장되는 값** | 값 자체 | 메모리 주소 (지도) |
| **저장 위치** | Stack 메모리 | Heap 메모리 |
| **예시** | `int`, `double`, `char`, `boolean` | `String`, `배열`, `클래스` |
| **메모리 관리** | 메서드 종료 시 자동 삭제 | **가비지 컬렉터(GC)**가 정리 |

---

## **4. 한눈에 보는 비유**

- **기본형**: **상자에 값 자체**가 들어 있는 것
    - 예: `int num = 10;` → `num` 상자 안에 `10`이 적힌 종이가 들어 있음
- **참조형**: **Heap 메모리 주소가 적힌 지도**가 들어 있는 것
    - 예: `String name = "홍길동";` → `name` 상자 안에는 `"홍길동"`이 적힌 **지도**가 있음
    - 실제 `"홍길동"`은 **Heap 메모리**에 저장됨

---

## **5. 기술 면접 대비 요약**

- **기본형은 Stack, 참조형은 Heap에 저장**
- **기본형은 값 자체 저장**, **참조형은 메모리 주소 저장**
- *Heap 메모리는 가비지 컬렉터(GC)**가 정리
- **String은 참조형**이며, 값이 아닌 **주소가 저장**됨
- **Wrapper 클래스**(`Integer`, `Double` 등)로 **기본형 ↔ 참조형 변환** 가능

---

### **📝 한눈에 보는 요약**

- **기본형**: Stack 저장, 값 자체 저장 (`int`, `double`, `char`, `boolean`)
- **참조형**: Heap 저장, 주소 저장 (`String`, `배열`, `클래스`)
- **Wrapper 클래스**: `Integer`, `Double` 등으로 **Auto-boxing, Auto-unboxing** 지원
- **Heap 메모리**는 **가비지 컬렉터(GC)**가 자동 정리

---

---

# **🔄 2단계 본문: 형변환이란? (타입 변환)**

---

## **1. 형변환(Type Casting)이란?**

- **형변환**은 **변수의 데이터 타입을 다른 타입으로 바꾸는 것**입니다.
- 예를 들어, **정수를 실수로 바꾸거나** **문자열을 숫자로 바꾸는 것**이 형변환입니다.
- **숫자 상자를 다른 크기의 상자로 옮기는 것**에 비유할 수 있습니다.
    - 작은 상자에 있던 물건을 큰 상자로 옮기거나
    - 큰 상자에 있던 물건을 작은 상자로 옮길 때 내용물이 일부 없어질 수 있음

---

## **2. 기본형 ↔ 기본형 형변환**

**기본형끼리는 서로 형변환이 가능합니다.**

- 예: `int`, `double`, `char` 등
- **두 가지 방법**이 있습니다:
    1. **자동 형변환 (묵시적 변환)**
    2. **강제 형변환 (명시적 변환)**

---

### **1) 자동 형변환 (묵시적 변환)**

- **작은 크기 타입 → 큰 크기 타입**으로 자동 변환됩니다.
- **데이터 손실이 없기 때문에** 자바가 자동으로 변환해 줍니다.
- **상자를 더 큰 상자로 옮기는 것**에 비유할 수 있습니다.

```java
int num = 10;
double d = num;  // int → double 자동 변환
```

**🔹 비유: 작은 상자 → 큰 상자**

- `num`이라는 **작은 상자**에 들어 있던 `10`을
- `d`라는 **큰 상자**에 옮겨 담습니다.
- **큰 상자에 작은 물건이 들어가므로 문제 없음**

---

### **2) 강제 형변환 (명시적 변환)**

- **큰 크기 타입 → 작은 크기 타입**으로 변환할 때 사용합니다.
- **데이터 손실 가능성이 있기 때문에** 개발자가 **강제로 변환**해야 합니다.
- **큰 상자를 작은 상자로 옮길 때 내용물이 일부 없어질 수 있음**

```java
double d = 9.99;
int num = (int) d;  // double → int 강제 변환 (소수점 손실)
```

**🔹 비유: 큰 상자 → 작은 상자**

- `d`라는 **큰 상자**에 들어 있던 `9.99`를
- `num`이라는 **작은 상자**에 옮겨 담습니다.
- 이때 **소수점(.99)**이 잘려 나가고 **정수 부분(9)**만 저장됩니다.

---

### **자동 형변환과 강제 형변환 요약**

| **형변환 종류** | **설명** | **예시** |
| --- | --- | --- |
| **자동 형변환** | 작은 타입 → 큰 타입 | `int → double`, `char → int` |
| **강제 형변환** | 큰 타입 → 작은 타입 | `double → int`, `long → int` |
| **데이터 손실 여부** | 없음 | 있을 수 있음 (소수점 등) |
| **사용법** | 자동 변환 | `(타입) 값` 으로 변환 |

---

## **3. 기본형 ↔ 참조형 형변환**

- **직접 변환할 수 없습니다.**
- **기본형은 값 자체**를, **참조형은 메모리 주소**를 저장하기 때문입니다.
- 단, **Wrapper 클래스**를 사용하면 가능합니다:
    - `Integer`, `Double`, `Boolean` 등 기본형을 객체로 다루는 클래스
    - **Auto-boxing**과 **Auto-unboxing**이라는 기능 덕분에 쉽게 변환할 수 있습니다.

---

### **Wrapper 클래스를 통한 형변환**

```java
int num = 50;
Integer obj = num;  // Auto-boxing (기본형 → 참조형)
int newNum = obj;   // Auto-unboxing (참조형 → 기본형)
```

- **Auto-boxing**: 기본형 → 참조형 자동 변환
- **Auto-unboxing**: 참조형 → 기본형 자동 변환

**🔹 비유: 포장과 개봉**

- `num`이라는 **숫자 상자**를 `obj`라는 **포장 상자**에 넣음 (Auto-boxing)
- `obj` 포장 상자를 열어서 `newNum` 상자에 다시 담음 (Auto-unboxing)

---

### **Wrapper 클래스의 장점**

- **기본형과 참조형을 쉽게 변환**할 수 있습니다.
- **컬렉션(List, Map 등)에 기본형을 저장할 수 있습니다.**
    - 예: `ArrayList<Integer>`는 `int` 대신 `Integer` 타입을 저장
- **null 값**을 저장할 수 있습니다. (기본형은 `null` 저장 불가)

---

## **4. String(문자열) ↔ 기본형 형변환**

- `String`은 **참조형**이지만, **예외적으로 기본형과 형변환**이 가능합니다.
- 주로 **숫자를 문자열로 바꾸거나**, **문자열을 숫자로 바꿀 때** 사용합니다.

### **1) 기본형 → 문자열**

- `String.valueOf()` 또는 `+ ""` 사용

```java
int num = 100;
String str = String.valueOf(num);  // "100"
String str2 = num + "";  // "100"
```

### **2) 문자열 → 기본형**

- `Integer.parseInt()` 등 사용

```java
String str = "100";
int num = Integer.parseInt(str);  // 100
```

---

## **5. 기술 면접 대비 요약**

- **자동 형변환(묵시적 변환)**: 작은 타입 → 큰 타입 (데이터 손실 없음)
- **강제 형변환(명시적 변환)**: 큰 타입 → 작은 타입 (데이터 손실 가능)
- **기본형 ↔ 참조형 변환**은 **Wrapper 클래스**를 사용 (Auto-boxing, Auto-unboxing)
- **String ↔ 기본형 변환**은 `String.valueOf()`와 `Integer.parseInt()` 사용
- **Wrapper 클래스**는 **컬렉션**에 기본형 저장 및 **null 저장** 가능

---

### **📝 한눈에 보는 요약**

- **자동 형변환**: 작은 상자 → 큰 상자 (안전)
- **강제 형변환**: 큰 상자 → 작은 상자 (데이터 손실 가능)
- **Wrapper 클래스**: 기본형 ↔ 참조형 자동 변환 (포장과 개봉 비유)
- **String 변환**: `String.valueOf()`, `Integer.parseInt()` 사용

---

이렇게 정리하면 **노션(Notion)**에서 **가독성 높고 구조화된 문서**로 적합하게 구성됩니다.

혹시 수정하거나 추가하고 싶은 내용이 있으면 알려주세요!

---

# **🔢 3단계 본문: 실수형 형변환과 오차 문제**

---

## **1. 실수형 데이터 타입이란?**

- **실수형**은 **소수점이 있는 숫자**를 저장합니다.
- 자바에는 **두 가지 실수형 타입**이 있습니다:
    1. **float**: 작은 크기의 소수점 숫자 (소수점 이하 약 7자리 정밀도)
    2. **double**: 큰 크기의 소수점 숫자 (소수점 이하 약 15자리 정밀도)

```java
float f = 3.14f;
double d = 3.141592653589793;
```

- `f`: `float` 타입 (작은 크기) → 숫자 뒤에 `f`를 붙여야 함
- `d`: `double` 타입 (큰 크기) → 기본 실수형 타입 (숫자 뒤에 `d` 생략 가능)

---

## **2. float ↔ double 형변환**

- `float`에서 `double`로는 **자동 형변환**됩니다.
    - **작은 상자 → 큰 상자**로 옮기는 것이므로 안전
- `double`에서 `float`로는 **강제 형변환**해야 합니다.
    - **큰 상자 → 작은 상자**로 옮기는 것이므로 **소수점 이하 데이터 손실** 가능

---

### **자동 형변환 (float → double)**

```java
float f = 3.14f;
double d = f;  // float → double 자동 변환
System.out.println(d);  // 출력: 3.14
```

- *작은 상자(f)**에 있던 `3.14`를 **큰 상자(d)**에 옮깁니다.
- **데이터 손실 없이 그대로 저장**됩니다.

---

### **강제 형변환 (double → float)**

```java
double d = 3.141592653589793;
float f = (float) d;  // double → float 강제 변환
System.out.println(f);  // 출력: 3.1415927
```

- *큰 상자(d)**에 있던 `3.141592653589793`을
- *작은 상자(f)**에 옮깁니다.
- **소수점 이하 일부 데이터가 손실**되고, `3.1415927`로 저장됩니다.

**🔹 비유: 큰 컵 → 작은 컵**

- 큰 컵(d)에 물이 가득 찼을 때, 작은 컵(f)으로 옮기면
- **넘치면서 일부 물이 버려짐 (소수점 데이터 손실)**

---

## **3. 실수형에서 발생하는 오차 문제 (부동소수점 오차)**

- **컴퓨터는 0과 1로 숫자를 표현**합니다.
- **소수점 숫자를 정확하게 표현하기 어렵기 때문에** 오차가 발생할 수 있습니다.

---

### **예시: 부동소수점 오차 문제**

```java
double a = 0.1;
double b = 0.2;
System.out.println(a + b);          // 출력: 0.30000000000000004
System.out.println(a + b == 0.3);   // 출력: false
```

- `0.1`과 `0.2`는 **이진수로 완벽하게 표현할 수 없는 소수점**입니다.
- **0.30000000000000004**로 출력되며, **0.3과 같지 않다고 인식**합니다.

**🔹 비유: 동전 반쪽을 정확히 나누기 어렵다!**

- 동전 반쪽을 자르면 정확히 똑같이 나눌 수 없듯이,
- 컴퓨터도 **일부 소수점 숫자를 정확히 표현할 수 없음**

---

## **4. 부동소수점 오차 해결 방법**

### **1) `Math.abs()`를 사용한 비교**

- **두 실수의 차이를 절대값**으로 구해서 **매우 작으면 같은 값**으로 인식
- 오차 범위를 설정하여 비교
    
    ```java
    double a = 0.1;
    double b = 0.2;
    double result = a + b;
    
    boolean isEqual = Math.abs(result - 0.3) < 0.000001;
    System.out.println(isEqual);  // 출력: true
    ```
    
- `0.000001` 같은 **매우 작은 오차 범위** 안에 들어오면 **같다고 판단**

**🔹 비유: 동전 두 개의 무게 차이가 아주 작으면 같은 무게로 보기**

- **완전히 똑같지는 않지만** 차이가 거의 없으면 **같은 무게로 인식**

---

### **2) `BigDecimal` 클래스를 사용한 해결 방법**

- **정확한 소수점 계산**을 위해 사용하는 **클래스**입니다.
- 주로 **금융 계산**이나 **정밀도가 중요한 계산**에 사용됩니다.

```java
import java.math.BigDecimal;

BigDecimal a = new BigDecimal("0.1");
BigDecimal b = new BigDecimal("0.2");
BigDecimal result = a.add(b);

System.out.println(result);  // 출력: 0.3
```

- **문자열 형태**로 입력하면 **정확한 소수점 계산** 가능
- `new BigDecimal(0.1)`처럼 **실수를 직접 입력하면 부동소수점 오차 발생**

**🔹 비유: 정밀 저울 사용하기**

- **정확한 무게**를 재기 위해 **정밀 저울**을 사용하는 것처럼,
- **BigDecimal**은 **정확한 소수점 계산**을 위해 사용

---

## **5. 기술 면접 대비 요약**

- **float → double**: 자동 형변환 (문제 없음)
- **double → float**: 강제 형변환 필요, **정밀도 손실 발생 가능**
- **부동소수점 오차 문제**는 **컴퓨터가 소수점을 정확히 표현할 수 없어서 발생**
- **오차 해결 방법**:
    - `Math.abs()`로 **오차 범위 설정** 후 비교
    - `BigDecimal` 클래스로 **정확한 소수점 계산**
- **금융 계산**이나 **정밀도가 중요한 경우**에는 `BigDecimal` 사용

---

### **📝 한눈에 보는 요약**

- **float ↔ double 형변환**
    - `float → double`: 자동 변환 (안전)
    - `double → float`: 강제 변환 (정밀도 손실 가능)
- **부동소수점 오차 문제**
    - `0.1`, `0.2` 같은 소수를 **정확히 표현할 수 없음**
    - `Math.abs()`로 오차 범위 설정 또는 `BigDecimal` 사용
- **BigDecimal 사용법**
    - `new BigDecimal("숫자")`처럼 **문자열 형태로 입력**
    - `add()` 메서드로 더하기 (`.add()` → 더하기, `.subtract()` → 빼기)

---

---

# **📂 4단계 본문: Stack과 Heap의 차이점**

---

## **1. Stack(스택)과 Heap(힙)이란?**

- *Stack(스택)**과 **Heap(힙)**은 **컴퓨터 메모리**에서 **데이터를 저장하는 공간**입니다.
- **기본형**과 **참조형**이 각각 **다른 곳에 저장**되며, **관리 방식**도 다릅니다.

---

### **1) Stack(스택)이란?**

- **작고 빠른 메모리** 공간입니다.
- **기본형 변수**와 **메서드 실행 정보**가 저장됩니다.
- **LIFO(Last In, First Out)** 구조: 마지막에 들어온 데이터가 **가장 먼저 나감**
    - 예: 책을 위로 쌓았다가 **맨 위 책부터 꺼내는 방식**
- **메서드가 끝나면** **자동으로 사라집니다.**
    - 예: 메서드가 끝나면 **책 한 묶음이 통째로 사라짐**

---

### **예시: Stack에 저장되는 데이터**

```java
int num = 10;
double pi = 3.14;
```

- `num`과 `pi`는 **기본형 변수**이므로 **Stack에 저장**됩니다.
- Stack 메모리 구조:
    
    ```
    |   pi   |  3.14   |
    |  num   |   10    |
    |--------- 메모리 끝 (제일 위) --------|
    ```
    

**🔹 비유: 접시 쌓기**

- `num`이라는 접시에 `10`이라는 숫자를 적어서 쌓음
- 그 위에 `pi`라는 접시에 `3.14`를 적어서 쌓음
- *마지막에 쌓은 pi(3.14)**가 **가장 먼저 꺼내짐**

---

### **Stack의 특징 요약**

- **기본형 데이터**와 **메서드 실행 정보** 저장
- **LIFO 구조** (마지막에 쌓은 것이 가장 먼저 꺼내짐)
- **메서드가 끝나면 자동으로 사라짐**
- **빠르지만 크기가 작음** (`StackOverflowError` 발생 가능)

---

### **2) Heap(힙)이란?**

- **크고 느린 메모리** 공간입니다.
- `new`로 생성된 **객체와 배열**이 저장됩니다.
- **참조형 변수**는 **Heap에 저장된 객체의 주소**를 **Stack에 저장**합니다.
- *가비지 컬렉터(GC)**가 **사용하지 않는 객체를 정리**합니다.

---

### **예시: Heap에 저장되는 데이터**

```java
String name = "홍길동";
int[] scores = {90, 85, 95};
```

- `"홍길동"` 문자열과 `{90, 85, 95}` 배열은 **Heap에 저장**됩니다.
- `name`과 `scores`는 **Heap에 저장된 데이터의 주소**가 **Stack에 저장**됩니다.

**메모리 구조:**

- **Stack 메모리**
    
    ```
    |  scores  |  → 0x1000 |
    |   name   |  → 0x2000 |
    |---------- Stack 끝 -------------|
    ```
    
- **Heap 메모리**
    
    ```
    |  0x1000  |  {90, 85, 95}  |
    |  0x2000  |   "홍길동"    |
    |---------- Heap 끝 -------------|
    ```
    
    - `name`은 `"홍길동"`의 **메모리 주소(0x2000)**를 **Stack에 저장**
    - `"홍길동"` 자체는 **Heap 메모리 0x2000 위치**에 저장
    - `scores`는 `{90, 85, 95}` 배열의 **주소(0x1000)**를 **Stack에 저장**
    - `{90, 85, 95}` 배열은 **Heap 메모리 0x1000 위치**에 저장

**🔹 비유: 지도와 집**

- `name` 상자에는 `"홍길동"`이라는 **집 주소**가 적힌 **지도**가 들어 있음
- 실제 `"홍길동"`이라는 집은 **Heap 메모리**에 지어져 있음
- `scores` 상자에도 **지도**가 들어 있고, 실제 점수 배열은 **Heap 메모리**에 있음

---

### **Heap의 특징 요약**

- **참조형 데이터**(객체, 배열)가 저장됨
- **Stack에는 Heap 주소(지도)가 저장**됨
- *가비지 컬렉터(GC)**가 **사용하지 않는 객체**를 **자동으로 정리**
- **크기가 크지만 속도가 느림** (`OutOfMemoryError` 발생 가능)

---

## **3. Stack과 Heap의 차이점 요약**

| **항목** | **Stack(스택)** | **Heap(힙)** |
| --- | --- | --- |
| **저장 위치** | 메서드 호출 시 생성 | `new`로 생성된 객체 저장 |
| **저장 데이터** | 기본형 변수, 메서드 호출 정보 | 객체, 배열 |
| **관리 방식** | 자동 삭제 (메서드 종료 시) | **Garbage Collector(GC)**가 정리 |
| **속도** | 매우 빠름 | 상대적으로 느림 |
| **에러 발생** | `StackOverflowError` (재귀 무한 호출) | `OutOfMemoryError` (메모리 부족) |

---

## **4. 스택 오버플로우(StackOverflowError)란?**

- **Stack 메모리가 가득 찼을 때** 발생하는 에러입니다.
- **재귀 함수가 무한 호출**될 때 발생하기 쉽습니다.

```java
public class StackOverflowExample {
    public static void recursive() {
        recursive();  // 자신을 계속 호출 (무한 루프)
    }
    public static void main(String[] args) {
        recursive();
    }
}
```

**🔹 비유: 접시 쌓기 무한 반복**

- **접시가 무한히 쌓이면** 접시탑이 무너짐
- **Stack 메모리가 무한히 쌓이면** `StackOverflowError` 발생

---

## **5. 기술 면접 대비 요약**

- **Stack**: **기본형 데이터**와 **메서드 실행 정보**가 저장됨
- **Heap**: **참조형 데이터(객체, 배열)**가 저장됨
- **Stack은 빠르고 자동 관리**, **Heap은 느리고 GC가 정리**
- **StackOverflowError**: **재귀 호출 무한 반복** 시 발생
- **OutOfMemoryError**: **Heap 메모리 부족** 시 발생

---

### **📝 한눈에 보는 요약**

- **Stack**: 기본형, 메서드 정보 저장 → **빠르고 자동 삭제**
- **Heap**: 객체, 배열 저장 → **느리지만 크고, GC가 정리**
- **StackOverflowError**: Stack이 가득 찰 때 발생 (무한 재귀 호출)
- **OutOfMemoryError**: Heap이 가득 찰 때 발생 (메모리 누수)

---

# **📝 5단계 본문: String(문자열)이란?**

---

## **1. String(문자열)이란?**

- *String(문자열)**은 **여러 글자를 이어붙인 것**입니다.
- *문자 하나(`char`)**가 여러 개 모여서 **문자열(`String`)**이 됩니다.
- 자바에서 **문자열은 참조형**입니다.
    - **값 자체가 아닌 "주소"를 저장**합니다.
    - **Heap 메모리**에 문자열이 저장되고,
    - **Stack 메모리**에는 문자열이 있는 **주소(지도)**가 저장됩니다.

---

### **예시: String 선언과 사용**

```java
String name = "홍길동";
String greeting = "안녕, " + name + "!";
System.out.println(greeting);  // 출력: 안녕, 홍길동!
```

- `name`이라는 **상자**에는 `"홍길동"`이 **직접 들어있는 게 아니고**
- `"홍길동"`이 저장된 **Heap 메모리의 주소**가 적힌 **지도 같은 종이**가 들어 있습니다.
- `"안녕, 홍길동!"` 문자열도 **Heap 메모리**에 저장되고, **주소**가 `greeting`에 저장됩니다.

---

### **String의 특징 요약**

- **문자열은 참조형** → **Heap 메모리**에 저장
- **값 자체가 아닌 주소(지도)가 Stack에 저장**
- **불변(Immutable)**: 한 번 생성된 문자열은 **변경할 수 없음**
    - 문자열을 바꾸면 **새로운 문자열이 Heap에 생성**되고 **주소만 바뀜**
    - 예: `"홍길동"`에서 `"김철수"`로 바꾸면
        - `"김철수"`가 **새로 만들어지고**, `name`이 가리키는 **주소가 바뀜**

---

## **2. String의 불변(Immutable) 특징**

- *String은 불변(Immutable)**합니다.
- **한 번 만들어진 문자열은 바꿀 수 없고**, 바꾸려면 **새로운 문자열이 생성**됩니다.

---

### **예시: String 불변의 특징**

```java
String str1 = "Hello";
String str2 = str1;
str1 = str1 + " World";

System.out.println(str1);  // 출력: Hello World
System.out.println(str2);  // 출력: Hello
```

- `"Hello"`가 **Heap 메모리에 저장**되고, `str1`과 `str2`가 **같은 주소**를 가리킴
- `str1`에 `" World"`를 붙이면
    - **기존의 `"Hello"`는 그대로 남아있고**
    - **새로운 문자열 `"Hello World"`가 생성**되며
    - `str1`은 **새 주소**를 가리키고, `str2`는 **변경되지 않음**

**🔹 비유: 복사한 지도**

- `str1`과 `str2`는 **같은 지도를 복사해서 들고 있음**
- `str1`이 **새로운 곳으로 이사**가면
- `str2`는 **옛날 집 주소가 적힌 지도**를 그대로 들고 있음

---

## **3. String 변환 방법**

### **1) 기본형 → String(문자열) 변환**

- **숫자, 문자 등 기본형 데이터를 문자열로 바꾸는 방법**
- **`String.valueOf()`** 또는 **`+ ""`*를 사용합니다.

```java
int num = 100;
String str1 = String.valueOf(num);  // "100"
String str2 = num + "";  // "100"
```

- `String.valueOf()`는 **모든 타입**을 문자열로 바꿀 수 있음
- `+ ""`는 **숫자에 빈 문자열**을 더해 **문자열로 만듦**

**🔹 비유: 이름표 붙이기**

- 숫자 `100`에 **이름표(`""`)를 붙이면** `"100"`이라는 글자로 바뀜

---

### **2) String(문자열) → 기본형 변환**

- **문자열에서 숫자 등 기본형 데이터로 바꾸는 방법**
- **Wrapper 클래스**의 **`parseXXX()`** 메서드를 사용합니다.

```java
String str = "100";
int num = Integer.parseInt(str);  // 10
```

- `Integer.parseInt()`는 **문자열**을 **정수(int)**로 바꿉니다.
- **문자열 내부에 숫자가 아닌 문자가 있으면 에러 발생**
    
    ```java
    String str = "100a";
    int num = Integer.parseInt(str);  // NumberFormatException 발생
    ```
    

**🔹 비유: 이름표 떼기**

- `"100"`이라는 글자에서 **이름표(`""`)를 떼면** 숫자 `100`이 나옴

---

## **4. StringBuffer와 StringBuilder**

- **String은 불변**이라서 **문자열을 자주 바꾸면 새로운 객체가 계속 생성**됩니다.
- **StringBuffer**와 **StringBuilder**는 **문자열을 자유롭게 변경**할 수 있습니다.
- **Heap 메모리**에 **하나의 객체**만 유지하며 **내용만 바꿈**
- 문자열을 **자주 추가, 수정, 삭제**할 때 **성능이 좋음**

---

### **예시: StringBuffer 사용법**

```java
StringBuffer sb = new StringBuffer("Hello");
sb.append(" World");
System.out.println(sb.toString());  // 출력: Hello World
```

- `.append()`는 **문자열을 뒤에 추가**합니다.
- **기존 문자열을 바꾸지 않고**, **하나의 객체에서 내용만 바꿈**
- `String`으로 바꾸려면 **`.toString()`** 사용

**🔹 비유: 수정 가능한 이름표**

- **String은 이름표가 떼어지지 않지만**,
- **StringBuffer는 수정 가능한 이름표**라서 **글자를 덧붙일 수 있음**

---

### **String vs StringBuffer vs StringBuilder**

| **특징** | **String** | **StringBuffer** | **StringBuilder** |
| --- | --- | --- | --- |
| **변경 가능 여부** | **불변 (Immutable)** | 변경 가능 (가변) | 변경 가능 (가변) |
| **메모리 사용** | **새 객체 생성** | **하나의 객체에서 내용 변경** | **하나의 객체에서 내용 변경** |
| **속도** | 느림 (새 객체 생성) | 빠름 | 가장 빠름 |
| **쓰레드 안전성** | **쓰레드 안전하지 않음** | **쓰레드 안전** | **쓰레드 안전하지 않음** |
| **사용 예시** | **변하지 않는 문자열** | **멀티쓰레드 환경** | **단일 쓰레드 환경** |

---

## **5. 기술 면접 대비 요약**

- **String은 불변(Immutable)** → **새로운 문자열이 생성**되고 **주소만 바뀜**
- **String → 기본형**: `Integer.parseInt()` 사용
- **기본형 → String**: `String.valueOf()` 또는 `+ ""` 사용
- **문자열 자주 수정**할 때는 **StringBuffer** 또는 **StringBuilder** 사용
- **StringBuffer는 쓰레드 안전**, **StringBuilder는 빠르지만 쓰레드 안전하지 않음**

---

---

# **📦 6단계 본문: Wrapper 클래스와 Auto-boxing**

---

## **1. Wrapper 클래스란?**

- **Wrapper 클래스**는 **기본형 데이터를 객체로 다룰 수 있게** 만든 클래스입니다.
- 자바에는 **8개의 기본형**에 대응하는 **8개의 Wrapper 클래스**가 있습니다.

| **기본형(Primitive Type)** | **Wrapper 클래스** |
| --- | --- |
| `int` | `Integer` |
| `double` | `Double` |
| `char` | `Character` |
| `boolean` | `Boolean` |
| `byte` | `Byte` |
| `short` | `Short` |
| `long` | `Long` |
| `float` | `Float` |
- 예를 들어, `int`는 **값 자체를 저장**하지만,
- `Integer`는 **값 대신 객체의 주소(지도)**가 저장됩니다.

---

### **예시: 기본형 vs Wrapper 클래스**

```java
int num = 10;               // 기본형
Integer obj = new Integer(10);  // Wrapper 클래스
```

- `num`: **Stack에 값(10)**이 **직접 저장**됨
- `obj`: **Stack에는 주소(지도)**가 저장되고,
    - *Heap에는 실제 값(10)**이 저장됨

**🔹 비유: 종이와 상자**

- `num`은 **종이에 숫자 10이 직접 적혀 있음**
- `obj`는 **상자에 숫자가 적힌 종이가 들어 있음**
    - 종이는 **Heap에 저장**되고,
    - 상자에는 **종이가 들어 있는 장소(주소)가 적힌 지도**가 들어 있음

---

### **Wrapper 클래스의 특징 요약**

- **기본형 값을 객체처럼 다룰 수 있음**
- **값이 아닌 주소(지도)를 저장** (Heap에 객체가 저장)
- **null 값을 저장 가능**
- **컬렉션(List, Map 등)에 저장 가능**
    - `ArrayList<Integer>`처럼 **기본형은 컬렉션에 저장할 수 없지만**
    - **Wrapper 클래스**는 저장할 수 있음

---

## **2. Auto-boxing과 Auto-unboxing**

- **Auto-boxing**: 기본형 → Wrapper 클래스로 **자동 변환**
- **Auto-unboxing**: Wrapper 클래스 → 기본형으로 **자동 변환**

---

### **Auto-boxing 예시**

```java
int num = 100;
Integer obj = num;  // Auto-boxing
```

- `int num`이 `Integer obj`로 **자동 변환**됩니다.
- *num의 값(100)**은 **Heap 메모리**에 저장되고,
- `obj`에는 **Heap 주소(지도)**가 저장됩니다.

**🔹 비유: 상자에 담기**

- **숫자 100이 적힌 종이**를 **상자에 담아서 보관**
- 상자 위치는 **지도**에 표시하고, 그 지도를 `obj`가 가지고 있음

---

### **Auto-unboxing 예시**

```java
Integer obj = 200;
int num = obj;  // Auto-unboxing
```

- `Integer obj`가 `int num`으로 **자동 변환**됩니다.
- `obj`가 **가리키는 Heap 주소**에서 **값(200)**을 꺼내서
- `num`에 **직접 저장**합니다.

**🔹 비유: 상자에서 꺼내기**

- `obj`가 **지도**를 보고 **상자가 있는 장소**로 이동
- 상자를 열어서 **숫자 200이 적힌 종이**를 꺼내고,
- *종이에 적힌 숫자(200)**를 `num`에 **직접 저장**

---

### **Auto-boxing과 Auto-unboxing의 장점**

- **기본형**과 **Wrapper 클래스**를 **편리하게 섞어서 사용**할 수 있습니다.
- *컬렉션(List, Map 등)**에 **기본형 데이터를 저장**할 수 있습니다.
- **형변환 코드가 줄어들어 가독성이 좋아집니다.**

---

### **Auto-boxing과 Auto-unboxing 주의점**

- **null 값을 Auto-unboxing**하면 **NullPointerException**이 발생합니다.
    
    ```java
    Integer obj = null;
    int num = obj;  // NullPointerException 발생
    ```
    
- **Wrapper 클래스는 비교 시 주의**해야 합니다.
    
    ```java
    java
    복사편집
    Integer a = 100;
    Integer b = 100;
    System.out.println(a == b);  // true
    
    Integer c = 1000;
    Integer d = 1000;
    System.out.println(c == d);  // false
    
    ```
    
    - **`128 ~ 127` 사이의 값**은 **캐싱**되어 같은 주소를 가리킵니다.
    - **그 외의 값**은 **새로운 객체가 생성**되므로 **주소가 다릅니다.**
    - *값 자체를 비교하려면 `.equals()`*를 사용해야 합니다.

---

### **`.equals()` 메서드로 비교하기**

```java
Integer a = 1000;
Integer b = 1000;
System.out.println(a.equals(b));  // true
```

- `.equals()`는 **값 자체를 비교**하므로 **항상 정확하게 비교**할 수 있습니다.

**🔹 비유: 상자 안의 내용물 비교하기**

- `==`는 **상자가 같은지** 확인 → 상자가 다르면 `false`
- `.equals()`는 **상자 안의 내용물**이 같은지 확인 → 내용물이 같으면 `true`

---

## **3. Wrapper 클래스의 주요 메서드**

| **메서드** | **설명** | **예시** |
| --- | --- | --- |
| `parseXXX()` | **문자열 → 기본형** 변환 | `int num = Integer.parseInt("100");` |
| `valueOf()` | **문자열 → Wrapper 클래스** 변환 | `Integer obj = Integer.valueOf("100");` |
| `toString()` | **Wrapper 클래스 → 문자열** 변환 | `String str = obj.toString();` |
| `compareTo()` | **값 비교** (`양수/0/음수` 반환) | `int result = obj1.compareTo(obj2);` |
| `equals()` | **값 자체를 비교** | `boolean isEqual = obj1.equals(obj2);` |

---

## **4. 기술 면접 대비 요약**

- **Wrapper 클래스**는 **기본형을 객체처럼 다룰 수 있게** 만든 클래스
- **Auto-boxing**: 기본형 → Wrapper 클래스로 자동 변환
- **Auto-unboxing**: Wrapper 클래스 → 기본형으로 자동 변환
- **null 값을 Auto-unboxing**하면 **NullPointerException** 발생
- **Wrapper 클래스는 `.equals()`로 값 비교**해야 정확하게 비교 가능
- *컬렉션(List, Map 등)**에 기본형 데이터를 저장할 때 사용

---

### **📝 한눈에 보는 요약**

- **Wrapper 클래스**: 기본형을 객체처럼 사용 (`int` ↔ `Integer`)
- **Auto-boxing**: 기본형 → Wrapper 클래스로 자동 변환
- **Auto-unboxing**: Wrapper 클래스 → 기본형으로 자동 변환
- **`.equals()`로 값 비교**, `==`는 주소 비교
- **null 주의**: `Integer obj = null; int num = obj;` → `NullPointerException` 발생

---

---

# **🎓 7단계 본문: 형변환 심화 개념 및 면접 대비**

---

## **1. 형변환(Type Casting)이 필요한 이유**

- **데이터 타입마다 저장 방식이 다르기 때문**입니다.
- 예를 들어, **정수는 소수점이 없고**, **실수는 소수점이 있습니다.**
- **다른 타입끼리 계산**하려면 **같은 타입으로 맞춰야** 합니다.
    - 예: `int`와 `double`을 더할 때는 **둘 중 하나를 변환**해야 함
        
        ```java
        int num = 10;
        double pi = 3.14;
        double result = num + pi;  // int → double 자동 변환
        ```
        

---

### **형변환의 필요성 요약**

- **서로 다른 타입을 계산**하려면 **같은 타입**으로 맞춰야 함
- **작은 타입 → 큰 타입**: 자동 형변환 (안전)
- **큰 타입 → 작은 타입**: 강제 형변환 (데이터 손실 가능)

---

## **2. 형변환의 종류 요약**

- **기본형 ↔ 기본형**
    - **자동 형변환**: 작은 타입 → 큰 타입 (예: `int → double`)
    - **강제 형변환**: 큰 타입 → 작은 타입 (예: `double → int`, 소수점 손실 가능)
- **기본형 ↔ 참조형**
    - **직접 변환 불가** (값 자체 vs 주소 차이 때문)
    - **Wrapper 클래스** 사용 (Auto-boxing, Auto-unboxing)
- **String ↔ 기본형**
    - `String.valueOf()` 또는 `+ ""` → **기본형 → String**
    - `Integer.parseInt()` → **String → 기본형**

---

## **3. 타입 변환 우선순위 (형변환 규칙)**

- **작은 타입 → 큰 타입**으로 자동 변환
- **낮은 정밀도 → 높은 정밀도**로 자동 변환
- 자바의 기본 형변환 **우선순위**는 다음과 같습니다:

```
byte → short → int → long → float → double
```

- 예를 들어, `int`와 `double`을 더하면 `int → double`로 자동 변환됨
    
    ```java
    int num = 10;
    double pi = 3.14;
    double result = num + pi;  // int → double 자동 변환
    ```
    

---

### **예시: 형변환 우선순위**

```java
int a = 10;
double b = 3.14;
double result = a + b;  // int → double 자동 변환
```

- `a`는 `int` (작은 타입), `b`는 `double` (큰 타입)
- **int → double**로 자동 변환되어 **`result`도 `double` 타입**이 됨

**🔹 비유: 큰 물통에 작은 물컵의 물을 붓기**

- 작은 물컵(`int`)의 물을 큰 물통(`double`)에 붓는 것은 문제 없음
- 큰 물통(`double`)의 물을 작은 물컵(`int`)에 부으면 **넘치면서 일부가 손실**

---

### **명시적 형변환 예시 (큰 타입 → 작은 타입)**

```java
double pi = 3.14;
int num = (int) pi;  // double → int 강제 변환 (소수점 손실)
System.out.println(num);  // 출력: 3
```

- `double`에서 `int`로 **강제 형변환**
- **소수점 이하가 잘려 나가고 정수 부분만 저장**됨

**🔹 비유: 큰 물통의 물을 작은 물컵에 옮기기**

- **넘치는 물은 버려지고** 남는 부분만 저장됨 (소수점 손실)

---

## **4. instanceof 연산자 (타입 확인)**

- **객체의 타입**을 **확인**할 때 사용합니다.
- 주로 **형변환하기 전에 타입을 검사**할 때 사용합니다.

---

### **예시: instanceof 사용법**

```java
Object obj = "Hello";
if (obj instanceof String) {
    String str = (String) obj;
    System.out.println(str.toUpperCase());  // 출력: HELLO
}
```

- `obj`가 **String 타입**인지 **확인**한 후,
- **문자열로 형변환**해서 **대문자로 바꿈**

**🔹 비유: 지도 확인하기**

- `obj`가 들고 있는 **지도를 확인**해서
- **String 집**을 가리키고 있다면 **문자열로 변환**

---

### **instanceof의 특징 요약**

- **타입을 확인**해서 **안전하게 형변환**할 수 있음
- **상속 관계에서도 사용 가능**
    
    ```java
    class Animal {}
    class Dog extends Animal {}
    
    Animal pet = new Dog();
    System.out.println(pet instanceof Animal);  // 출력: true
    System.out.println(pet instanceof Dog);     // 출력: true
    ```
    
- `pet`은 **Animal 타입**이면서 **Dog 타입**이기도 함 (상속 관계)

---

## **5. 기술 면접 대비 요약**

- **작은 타입 → 큰 타입**: 자동 형변환 (안전)
- **큰 타입 → 작은 타입**: 강제 형변환 (데이터 손실 가능)
- **instanceof 연산자**로 **타입 확인 후 형변환**
- **기본형 ↔ 참조형**: **Wrapper 클래스** 사용 (Auto-boxing, Auto-unboxing)
- **String ↔ 기본형**: `String.valueOf()`, `Integer.parseInt()` 사용
- **형변환 우선순위**: `byte → short → int → long → float → double`
- **값 비교 시 `.equals()` 사용**, `==`는 **주소 비교**
- **부동소수점 오차 문제** 해결: `Math.abs()` 또는 `BigDecimal` 사용

---

### **📝 한눈에 보는 요약**

- **자동 형변환**: 작은 타입 → 큰 타입 (예: `int → double`)
- **강제 형변환**: 큰 타입 → 작은 타입 (예: `double → int`, 소수점 손실)
- **instanceof**: **타입 확인 후 안전하게 형변환**
- **Wrapper 클래스**: 기본형 ↔ 참조형 자동 변환 (`Integer`, `Double` 등)
- **String 변환**: `String.valueOf()` 또는 `Integer.parseInt()` 사용
- **형변환 우선순위**: `byte → short → int → long → float → double`
- **부동소수점 오차 해결**: `Math.abs()` 또는 `BigDecimal` 사용

---
